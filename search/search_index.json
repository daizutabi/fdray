{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fdray","text":"<p>fdray is a Python library that provides a clean interface to POV-Ray, making it easy to create and render 3D scenes programmatically.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple Scene Description: Express 3D scenes in clean, readable   Python code</li> <li>Pythonic API: Natural integration with Python's ecosystem</li> <li>POV-Ray Integration: Seamless integration with a high-quality   rendering engine</li> <li>Jupyter Support: Interactive scene development in Jupyter   notebooks</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fdray\n</code></pre> <p>Requires POV-Ray to be installed:</p> <ul> <li>Linux: <code>sudo apt-get install povray</code></li> <li>macOS: <code>brew install povray</code></li> <li>Windows: Download from POV-Ray website</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from fdray import Camera, Color, LightSource, Scene, Sphere\n\n# Create a simple scene\nscene = Scene(\n    Camera(longitude=20, latitude=30),\n    LightSource(0, Color(\"white\")),  # 0: at camera location\n    Sphere((0, 0, 0), 1, Color(\"red\")),\n)\n\n# Render the scene\nscene.render(width=800, height=600)\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>POV-Ray team for their excellent ray tracing engine</li> <li>The Python community for inspiration and support</li> </ul>"},{"location":"tutorial/camera/","title":"Camera","text":"<p><code>Camera</code> class is used to configure the camera settings for the rendering.</p>"},{"location":"tutorial/camera/#positioning_1","title":"Positioning","text":"<p>We use a right-handed spherical coordinate system for camera positioning.</p> ResultSource <p></p> <pre><code>from fdray import *\n\nScene(\n    Camera(longitude=30, latitude=40),\n    LightSource(0, ColorName.WHITE),  # at camera location\n    Cylinder(0, (1, 0, 0), 0.1, Color(\"red\")),\n    Cylinder(0, (0, 1, 0), 0.1, Color(\"green\")),\n    Cylinder(0, (0, 0, 1), 0.1, Color(\"blue\")),\n).render(width=300, height=300)\n</code></pre> <p>In the above figure, the camera is positioned at:</p> <ul> <li>Longitude: 30 degrees</li> <li>Latitude: 40 degrees</li> </ul> <p>The camera position is determined through a two-step transformation:</p> <ol> <li>First, rotate 30 degrees counterclockwise from the x-axis toward    the y-axis in the x-y plane</li> <li>Then, elevate 40 degrees from that position toward the z-axis</li> </ol> <p>This coordinate system allows for intuitive camera positioning:</p> <ul> <li>Longitude controls the horizontal rotation around the scene</li> <li>Latitude controls the vertical angle from the ground plane</li> </ul>"},{"location":"tutorial/camera/#implementation","title":"Implementation","text":"<p>The camera implementation is based on the following Qiita article:</p> <ul> <li>Title: Efficient Camera Settings in POV-Ray</li> <li>Author: @Hyrodium (Yuto Horikawa)</li> <li>URL: https://qiita.com/Hyrodium/items/af91b1ddb8ea2c4359c2</li> <li>Date: 2017-12-07</li> </ul> <p>This implementation adopts the spherical coordinate system and uses the calculation methods for direction, right, and up vectors as proposed in the article. The sky parameter is also included as it's essential for proper orientation.</p>"},{"location":"tutorial/camera/#view-scale","title":"View scale","text":"<p>The <code>view_scale</code> parameter controls how much of the scene is visible in the rendered image. It functions similarly to adjusting a camera's field of view.</p> ResultSource <code>view_scale = 1</code> <code>view_scale = 2</code> <code>view_scale = 3</code> <pre><code>def scene_view_scale(view_scale: float):\n    return Scene(\n        Camera(0, 0, view_scale=view_scale),\n        LightSource(0, Color(\"white\")),\n        Cylinder(\"-y\", \"y\", 0.2, Color(\"green\")),\n        Cylinder(\"-2*y\", \"2*y\", 0.15, Color(\"green\")),\n        Cylinder(\"-3*y\", \"3*y\", 0.1, Color(\"green\")),\n        Cylinder(\"-z\", \"z\", 0.2, Color(\"blue\")),\n        Cylinder(\"-2*z\", \"2*z\", 0.15, Color(\"blue\")),\n        Cylinder(\"-3*z\", \"3*z\", 0.1, Color(\"blue\")),\n        Torus(1, 0.1, Color(\"purple\", 0.5)).rotate(\"90*z\"),\n        Torus(2, 0.1, Color(\"gold\", 0.5)).rotate(\"90*z\"),\n        Torus(3, 0.1, Color(\"cyan\", 0.5)).rotate(\"90*z\"),\n        Background(Color(\"gray\")),\n    ).render(width=150, height=150)\n</code></pre>"},{"location":"tutorial/camera/#basic-operation","title":"Basic Operation","text":"<ul> <li>A larger view scale shows more of the scene by \"zooming out\"</li> <li>A smaller view scale shows less of the scene by \"zooming in\"</li> </ul>"},{"location":"tutorial/camera/#technical-implementation","title":"Technical Implementation","text":"<ul> <li>The coordinate range rendered extends from <code>-view_scale</code> to <code>+view_scale</code></li> <li>Directly affects the apparent size of objects in the scene</li> <li>Controls the viewing frustum without changing camera position</li> </ul>"},{"location":"tutorial/camera/#parameter-relationships","title":"Parameter Relationships","text":"<ul> <li>Independent of camera position and orientation (longitude, latitude)</li> <li>Works in conjunction with the camera's distance parameter</li> </ul>"},{"location":"tutorial/camera/#distance","title":"Distance","text":"<p>The <code>distance</code> parameter controls the camera's perspective effect. This parameter significantly affects how the 3D scene is rendered, particularly the perspective distortion.</p> ResultSource <code>distance = 3</code> <code>distance = 10</code> <code>distance = 30</code> <pre><code>def scene_distance(distance: float):\n    return Scene(\n        Camera(15, 10, view_scale=2, distance=distance),\n        LightSource((1, 20, 40), Color(\"white\")),\n        Box(-1, 1, Color(\"green\", 0.8)),\n        Background(Color(\"gray\", 0.2)),\n    ).render(width=200, height=200)\n</code></pre>"},{"location":"tutorial/camera/#visual-effects","title":"Visual Effects","text":""},{"location":"tutorial/camera/#when-distance-is-small","title":"When distance is small","text":"<ul> <li>Creates a fisheye lens-like effect</li> <li>Produces strong perspective distortion</li> <li>Objects appear more curved at the edges</li> <li>Similar to viewing through a wide-angle lens</li> </ul>"},{"location":"tutorial/camera/#when-distance-is-large","title":"When distance is large","text":"<ul> <li>Approaches orthogonal projection</li> <li>Reduces perspective distortion</li> <li>Creates a more natural depth perception</li> <li>Similar to viewing through a telephoto lens</li> </ul>"},{"location":"tutorial/camera/#technical-details","title":"Technical Details","text":"<p>The <code>distance</code> parameter:</p> <ul> <li>Affects the perspective matrix calculation</li> <li>Does not change the actual size of objects, only their apparent   perspective</li> <li>Represents the distance between the camera position (<code>camera_pos</code>) and   the object's center (<code>center</code>)</li> <li>Smaller distances bring the camera closer to the object, creating   stronger perspective effects</li> <li>Larger distances move the camera away from the object, resulting in a   more orthogonal-like view</li> </ul>"},{"location":"tutorial/camera/#important-notes","title":"Important Notes","text":"<ul> <li>The <code>distance</code> parameter only affects perspective, not object size</li> <li>Smaller distances create more dramatic perspective effects</li> <li>Larger distances create more natural, less distorted views</li> <li>The effect is similar to changing the focal length of a camera lens</li> </ul>"},{"location":"tutorial/camera/#orbital-location","title":"Orbital Location","text":"<p>Calculate a position in orbit around the camera's location</p> <p>Imagine tilting your head up (<code>angle</code>) and then rotating counter-clockwise (<code>rotation</code>):</p> <ul> <li>First, move <code>forward</code> along viewing direction (0: at <code>camera.location</code>,   1: at <code>camera.look_at</code>). Negative values move behind the camera.</li> <li>Then, tilt up from viewing direction by <code>angle</code> degrees</li> <li>Finally, rotate counter-clockwise from up by <code>rotation</code> degrees   (0: up, 90: left, 180: down, 270: right)</li> </ul> <pre><code>from math import asin, degrees, sqrt\n\n\ndef render(camera: Camera, *args):\n    return Scene(\n        camera,\n        LightSource(0, \"white\"),\n        Cylinder(0, \"2*x\", 0.02, Color(\"red\")),\n        Cylinder(0, \"2*y\", 0.02, Color(\"green\")),\n        Cylinder(0, \"2*z\", 0.02, Color(\"blue\")),\n        *args,\n    ).render(width=300, height=300)\n\n\ndistance = 4\ncamera = Camera(0, 0, view_scale=2.5, look_at=(0, 0, 0), distance=distance)\nnorm = sqrt(distance**2 + 2**2)\nangle = degrees(asin(2 / norm))\np1 = camera.orbital_location(norm / distance, angle, -90)\ns1 = Sphere(p1, 0.2, Color(\"purple\", 0.5))\np2 = camera.orbital_location(0.5, angle, -90)\ns2 = Sphere(p2, 0.05, Color(\"orange\", 0.5))\nrender(camera, s1, s2)\n</code></pre> Rendered image from x axis Top view (y-z plane)"},{"location":"tutorial/camera/#movies","title":"Movies","text":""},{"location":"tutorial/camera/#camera_1","title":"Camera","text":""},{"location":"tutorial/camera/#orbital-location_1","title":"Orbital Location","text":""},{"location":"tutorial/light_source/","title":"Light Source","text":"<p><code>LightSource</code> class is used to configure the light source settings for the rendering.</p>"},{"location":"tutorial/light_source/#example","title":"Example","text":"<p>Here's a complete example of a scene with a light source:</p> <pre><code>from fdray import *\n\nScene(\n    Camera(0, 10, look_at=(0, 0, 0.5), view_scale=1.5, distance=3),\n    LightSource((0, 1, 4), \"white\", from_camera=False),\n    Sphere(\"z\", 0.4, Color((0.5, 0.7, 0.7))),\n    Box(-1, 1, Color(\"gold\")).translate(0, 0, -1),\n).render(200, 200)\n</code></pre> <p></p>"},{"location":"tutorial/light_source/#basic-usage","title":"Basic Usage","text":"<p>The <code>LightSource</code> class creates a light source in the 3D scene that provides illumination for rendered objects. A basic light source can be created with just a position and an optional color:</p> <pre><code>from fdray import LightSource, Color\n\n# Basic white light at absolute position (1, 2, 3)\nlight1 = LightSource((1, 2, 3), \"white\", from_camera=False)\n\n# Colored light using RGB values\nlight2 = LightSource((1, 2, 3), (0.8, 0.6, 0.3), from_camera=False)\n\n# Using Color object\nlight3 = LightSource((1, 2, 3), Color(\"blue\"), from_camera=False)\n</code></pre>"},{"location":"tutorial/light_source/#parameters","title":"Parameters","text":"<p>The <code>LightSource</code> class accepts the following parameters:</p> <ul> <li> <p><code>location</code>: Position of the light source. This can be:</p> <ul> <li>A tuple of coordinates <code>(x, y, z)</code> for absolute positioning</li> <li>A scalar value or tuple for camera-relative positioning (see below)</li> <li>A string for direct POV-Ray expressions</li> </ul> </li> <li> <p><code>color</code>: Color of the light. Can be specified as:</p> <ul> <li>A string with a color name (\"white\", \"red\", etc.)</li> <li>An RGB tuple with values between 0 and 1</li> <li>A <code>Color</code> object</li> </ul> </li> <li> <p><code>from_camera</code>: Boolean that determines if the light is positioned relative   to the camera:</p> <ul> <li><code>True</code> (default): The light position is calculated relative to the camera</li> <li><code>False</code>: The coordinates are used as absolute position</li> </ul> </li> <li> <p><code>shadowless</code>: Boolean that determines if the light casts shadows:</p> <ul> <li><code>True</code>: The light does not cast shadows</li> <li><code>False</code> (default): The light casts shadows</li> </ul> </li> <li> <p><code>fade_distance</code>: Distance at which the light begins to fade (optional)</p> </li> <li> <p><code>fade_power</code>: Rate at which the light intensity decreases with distance (optional)</p> </li> </ul>"},{"location":"tutorial/light_source/#camera-relative-positioning","title":"Camera-Relative Positioning","text":"<p>One of the most powerful features of the <code>LightSource</code> class is camera-relative positioning, which allows you to place lights relative to the camera's position and orientation.</p>"},{"location":"tutorial/light_source/#using-a-scalar-value","title":"Using a Scalar Value","text":"<p>When <code>from_camera=True</code> and <code>location</code> is a single number, the light is placed at a position calculated using <code>camera.orbital_location(location)</code>:</p> <pre><code># Light at the camera position (like a headlamp)\nlight = LightSource(0, \"white\")\n\n# Light positioned forward from the camera (between camera and look_at point)\nlight = LightSource(0.5, \"white\")  # Halfway to the look_at point\n</code></pre>"},{"location":"tutorial/light_source/#using-tuple-for-orbital-positioning","title":"Using Tuple for Orbital Positioning","text":"<p>For more control, you can provide a tuple of (forward, angle, rotation) to precisely position the light relative to the camera:</p> <pre><code># Light positioned above and to the left of the camera\nlight = LightSource((0.5, 30, -45), \"white\")\n\n# Parameters:\n# - 0.5: Half the distance from camera to look_at\n# - 30: Tilted up 30 degrees from viewing direction\n# - -45: Rotated 45 degrees clockwise from the up direction\n</code></pre> <p>This uses the camera's <code>orbital_location</code> method which calculates positions based on:</p> <ol> <li>Forward distance along viewing direction</li> <li>Upward angle from viewing direction</li> <li>Rotation around viewing direction</li> </ol>"},{"location":"tutorial/light_source/#important-notes","title":"Important Notes","text":"<p>When using camera-relative positioning (<code>from_camera=True</code>), you cannot directly convert a light source to a string. Instead, you need to use <code>Scene.to_str()</code> or <code>LightSource.to_str(camera)</code> to properly calculate the absolute position:</p> <pre><code>camera = Camera(30, 40)\nlight = LightSource(0, \"white\")\n\n# This will raise an error\n# str(light)\n\n# Use this instead:\nlight.to_str(camera)  # Returns the POV-Ray string with calculated position\n</code></pre>"},{"location":"tutorial/data/field/","title":"Field","text":"ResultSource <pre><code>import numpy as np\n\nfrom fdray import *\n\n\ndef get_object(x):\n    return Sphere(0, x, Color(\"blue\", alpha=2 * x))\n\n\nScene(\n    Camera(-90, 0, view_scale=1.5),\n    LightSource(0, \"white\"),\n    Union.from_field([0.2, 0.4, 0.3], get_object, ndim=0),\n).render(300, 200)\n</code></pre> ResultSource <pre><code>axes = Union(\n    Cylinder(0, \"0.7*x\", 0.02, Color(\"red\")),\n    Cylinder(0, \"0.7*y\", 0.02, Color(\"green\")),\n    Cylinder(0, \"0.7*z\", 0.02, Color(\"blue\")),\n)\n\narrow = Merge(\n    Cone((-0.1, 0, 0), 0.2, (0.6, 0, 0), 0.02),\n    Cylinder((-0.3, 0, 0), (0, 0, 0), 0.1),\n    Color(\"yellow\", transmit=0.5),\n    Finish(specular=0.3, brilliance=3),\n)\n\n\ndirection = [\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, -1, 0],\n    [0, 0, 1],\n    [0, 0, -1],\n    [1, 1, 1],\n    [1, -1, -1],\n]\n\nScene(\n    Camera(-70, 10, view_scale=1.7),\n    LightSource((0.4, 30, 40), \"white\"),\n    LightSource(0, \"white\"),\n    Union.from_field(direction, lambda x: (arrow.align(x), axes)),\n).render(600, 150)\n</code></pre> ResultSource <pre><code>x, y = np.meshgrid(np.arange(-4.5, 5), np.arange(-5.5, 6))\nn = np.sqrt(x**2 + y**2)\nmask = n &lt; 5\nfield = np.stack([y / n, x / n, 0.3 * (n - np.sqrt(5))], axis=-1)\nnorms = np.linalg.norm(field, axis=-1)\nfield = field / norms[..., None]\n\n\ndef get_arrow(x):\n    return Merge(\n        Cone((-0.1, 0, 0), 0.2, (0.6, 0, 0), 0.02),\n        Cylinder((-0.3, 0, 0), (0, 0, 0), 0.1),\n        Color.from_direction(x),\n        Finish(specular=0.3, brilliance=3),\n    ).align(x)\n\n\nScene(\n    Camera(-90, 90, view_scale=6),\n    LightSource((0.4, 30, 40), \"white\"),\n    LightSource(0, \"white\"),\n    Union.from_field(field, lambda x: (get_arrow(x), axes), mask=mask),\n).render(600, 600)\n</code></pre>"},{"location":"tutorial/data/region/","title":"Region","text":"ResultSource <pre><code>import numpy as np\n\nfrom fdray import *\n\nx = np.zeros((3, 4, 5), dtype=np.uint8)\nx[1:, 0, 0] = 1\nx[0, 1:, 0] = 2\nx[0, 0, 1:] = 3\n\n\ndef color_map(x):\n    return ColorMap({0: Color(\"white\"), 1: Color(x)})\n\n\nregion = Union.from_region(\n    x,\n    Box(-0.4, 0.4) - Box(0, 1),\n    mapping={\n        1: Pigment(\"granite\", color_map(\"red\")),\n        2: Pigment(\"wood\", color_map(\"blue\")),\n        3: Pigment(\"agate\", color_map(\"green\")),\n    },\n)\n\nScene(\n    Camera(40, 20, view_scale=3.5),\n    LightSource(0, \"white\"),\n    region,\n).render(500, 500)\n</code></pre>"},{"location":"tutorial/media/interior/","title":"Interior","text":""},{"location":"tutorial/media/interior/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(finish1, finish2, finish3):\n    floor = Pigment(\n        \"cells\",\n        ColorMap(\n            (0, Color((0.7, 0.6, 0.4))),\n            (0.4, Color((0.5, 0.8, 0.5))),\n            (1, Color((1, 1, 1))),\n        ),\n    ).scale(0.3)\n    sky = Pigment(\"wrinkles\", ColorMap((0.3, \"SkyBlue\"), (0.9, \"White\")))\n    sphere = Sphere((0, 0, 0), 0.4, Color((0.9, 0.9, 0.9), filter=1))\n    return Scene(\n        Include(\"colors.inc\"),\n        GlobalSettings(assumed_gamma=2.2),\n        Camera(0, -2, view_scale=1.2, distance=3),\n        LightSource((1.5, 25, 5), \"white\"),\n        Plane((0, 0, 1), -0.5, floor),\n        SkySphere(sky.scale(1, 0.2, 0.2)),\n        sphere.translate(0, -1, 0).add(finish1),\n        sphere.add(finish2),\n        sphere.translate(0, 1, 0).add(finish3),\n    ).render(600, 300)\n</code></pre>"},{"location":"tutorial/media/interior/#index-of-refraction","title":"Index of refraction","text":"<pre><code>render(\n    Interior(ior=1),  # air\n    Interior(ior=1.33),  # water\n    Interior(ior=1.51),  # glass\n)\n</code></pre>"},{"location":"tutorial/media/interior/#caustics_1","title":"Caustics","text":"<pre><code>render(\n    Interior(ior=1.51, caustics=0.2),\n    Interior(ior=1.51, caustics=0.4),\n    Interior(ior=1.51, caustics=0.8),\n)\n</code></pre>"},{"location":"tutorial/media/interior/#fade-distance_1","title":"Fade distance","text":"<pre><code>render(\n    Interior(ior=1.51, caustics=0.4, fade_distance=0),\n    Interior(ior=1.51, caustics=0.4, fade_distance=0.5),\n    Interior(ior=1.51, caustics=0.4, fade_distance=1),\n)\n</code></pre>"},{"location":"tutorial/media/interior/#material_1","title":"Material","text":"<pre><code>render(\n    Interior(\n        ior=1.33,\n        caustics=0.5,\n        fade_distance=10,\n        fade_power=1,\n        fade_color=(0.1, 0.3, 1.0),\n    ),\n    Interior(ior=1.51, caustics=1),\n    Interior(ior=1.6, dispersion=1.2, dispersion_samples=10),\n)\n</code></pre>"},{"location":"tutorial/object/csg/","title":"Constructive Solid Geometry","text":""},{"location":"tutorial/object/csg/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(*args):\n    return Scene(\n        Camera(30, 30, view_scale=2),\n        LightSource((1, 30, 40), \"white\"),\n        Cylinder((0, 0, 0), (3, 0, 0), 0.02, Color(\"red\")),\n        Cylinder((0, 0, 0), (0, 3, 0), 0.02, Color(\"green\")),\n        Cylinder((0, 0, 0), (0, 0, 3), 0.02, Color(\"blue\")),\n        *args,\n    ).render(width=300, height=300)\n\n\nsphere = Sphere(0, 0.8, Color(\"yellow\", 0.5)).translate(\"0.5*y\")\ncube = Cube(0, 2, Color(\"cyan\", 0.5)).translate(\"-0.5*y\")\n</code></pre>"},{"location":"tutorial/object/csg/#union_1","title":"Union","text":"<pre><code>render(Union(sphere, cube))  # or sphere + cube\n</code></pre>"},{"location":"tutorial/object/csg/#difference","title":"Difference","text":"<pre><code>render(Difference(sphere, cube))  # or sphere - cube\n</code></pre> <pre><code>render(Difference(cube, sphere))  # or cube - sphere\n</code></pre>"},{"location":"tutorial/object/csg/#intersection_1","title":"Intersection","text":"<pre><code>render(Intersection(sphere, cube))  # or sphere * cube\n</code></pre>"},{"location":"tutorial/object/csg/#merge_1","title":"Merge","text":"<pre><code>render(Merge(sphere, cube))  # or sphere | cube\n</code></pre>"},{"location":"tutorial/object/primitives/","title":"Primitive objects","text":""},{"location":"tutorial/object/primitives/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(*args):\n    return Scene(\n        Camera(20, 30, view_scale=2.2),\n        LightSource((0.5, 90, 40), \"white\"),\n        Cylinder((0, 0, 0), (2, 0, 0), 0.02, Color(\"red\")),\n        Cylinder((0, 0, 0), (0, 2, 0), 0.02, Color(\"green\")),\n        Cylinder((0, 0, 0), (0, 0, 2), 0.02, Color(\"blue\")),\n        *args,\n    ).render(width=300, height=300)\n</code></pre>"},{"location":"tutorial/object/primitives/#box_1","title":"Box","text":"<pre><code>render(Box(0, (1, 1.4, 1.8), Color(\"#ff33ff77\")))\n</code></pre>"},{"location":"tutorial/object/primitives/#cuboid_1","title":"Cuboid","text":"<pre><code>render(Cuboid(0, (1, 1.4, 1.8), Color(\"#33ffff77\")))\n</code></pre>"},{"location":"tutorial/object/primitives/#cube_1","title":"Cube","text":"<pre><code>render(Cube(0.5, 1.5, Color(\"gold\", 0.5)))\n</code></pre> <pre><code>render(Cube().pigment(Color(\"gold\", 0.5)))\n</code></pre>"},{"location":"tutorial/object/primitives/#cone_1","title":"Cone","text":"<pre><code>render(Cone(\"x\", 1, \"y\", 0.5, Color(\"darkgreen\", 0.5)))\n</code></pre> <pre><code>render(Cone(\"-0.5*x\", 1, \"z\", 0.5, \"open\", Color(\"dimgrey\", 0.5)))\n</code></pre>"},{"location":"tutorial/object/primitives/#cylinder_1","title":"Cylinder","text":"<pre><code>render(Cylinder(\"-z\", \"y\", 0.5, Color(\"dimgrey\", 0.5)))\n</code></pre>"},{"location":"tutorial/object/primitives/#plane_1","title":"Plane","text":"<pre><code>render(Plane(\"y\", 0.5, Color(\"pink\", 0.5)))\n</code></pre>"},{"location":"tutorial/object/primitives/#sphere_1","title":"Sphere","text":"<pre><code>render(Sphere(0, 1.5, Color(\"coral\", 0.5)))\n</code></pre> <pre><code>render(Sphere().pigment(Color(\"brown\", 0.5)).finish(phong=0.3))\n</code></pre>"},{"location":"tutorial/object/primitives/#sphere-sweep_1","title":"Sphere sweep","text":"ResultSource <pre><code>render(\n    SphereSweep(\n        \"linear_spline\",\n        [0, (0, 1, 0), (0, 0, 1.5), (2, 0, 0)],\n        [0.1, 0.2, 0.1, 0.2],\n    )\n    .pigment(Color(\"yellow\", 0.5))\n    .finish(phong=0.3),\n)\n</code></pre>"},{"location":"tutorial/object/primitives/#polyline","title":"Polyline","text":"ResultSource <pre><code>render(\n    Polyline([(0, 0, 0), (0, 1, 0), (0, 0, 1.5), (2, 0, 0)], 0.2)\n    .pigment(Color(\"purple\", 0.5))\n    .finish(phong=0.5, brilliance=0.5),\n)\n</code></pre>"},{"location":"tutorial/object/primitives/#curve","title":"Curve","text":"ResultSource <pre><code>render(\n    Curve([(0, 0, 0), (0, 1, 0), (0, 0, 1.5), (2, 0, 0)], 0.2)\n    .pigment(Color(\"ivory\", 0.5))\n    .finish(phong=0.5, brilliance=0.5),\n)\n</code></pre>"},{"location":"tutorial/object/primitives/#text_1","title":"Text","text":"<pre><code>Text.set_font(\"DejaVuSerif\")\n</code></pre> <p>'/usr/share/fonts/truetype/dejavu/DejaVuSerif.ttf'</p> <pre><code>render(Text(\"text\", 0.1, Color(\"teal\")))\n</code></pre> <p></p> <pre><code>render(Text(\"text\", 0, Color(\"teal\")).align())\n</code></pre> <p></p> <pre><code>render(Text(\"text\", 0, Color(\"teal\")).align(20, 30))\n</code></pre> <p></p>"},{"location":"tutorial/object/primitives/#torus_1","title":"Torus","text":"<pre><code>render(\n    Torus(1, 0.4, Color(\"cyan\", 0.5))\n    .finish(phong=0.3, reflection=0.5)\n    .rotate(90, 10, 20),\n)\n</code></pre>"},{"location":"tutorial/object/transformations/","title":"Transformations","text":""},{"location":"tutorial/object/transformations/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(*args):\n    return Scene(\n        Camera(10, 30, view_scale=3, look_at=(0, 3, 0)),\n        LightSource((1, 30, 40), \"white\"),\n        Cylinder((0, 0, 0), (2, 0, 0), 0.02, Color(\"red\")),\n        Cylinder((0, 0, 0), (0, 6, 0), 0.02, Color(\"green\")),\n        Cylinder((0, 0, 0), (0, 0, 2), 0.02, Color(\"blue\")),\n        *args,\n    ).render(width=600, height=300)\n\n\ncone = Cone(0, 0.4, \"1.4*x\", 0, Color(\"silver\", 0.8), Finish(specular=0.5))\n</code></pre>"},{"location":"tutorial/object/transformations/#translate_1","title":"Translate","text":"<pre><code>render(\n    cone,\n    cone.pigment(Color(\"red\")).translate(0, 1, 0),\n    cone.pigment(Color(\"green\")).translate(\"2*y\"),\n    cone.pigment(Color(\"blue\")).translate(\"3*y\").translate(1, 0, 0),\n    cone.pigment(Color(\"yellow\")).translate(-1, 4, 1),\n)\n</code></pre>"},{"location":"tutorial/object/transformations/#rotate_1","title":"Rotate","text":"<pre><code>render(\n    cone,\n    cone.pigment(Color(\"red\")).rotate(0, 90, 0).translate(\"y\"),\n    cone.pigment(Color(\"green\")).rotate(0, -90, 0).translate(\"2*y\"),\n    cone.pigment(Color(\"blue\")).rotate(0, 0, 90).translate(\"3*y\"),\n    cone.pigment(Color(\"yellow\")).rotate(0, 0, -90).translate(\"6*y\"),\n)\n</code></pre>"},{"location":"tutorial/object/transformations/#scale_1","title":"Scale","text":"<pre><code>render(\n    cone,\n    cone.pigment(Color(\"red\")).scale(1.2).translate(\"y\"),\n    cone.pigment(Color(\"green\")).scale(1.2, 0.8, 1.6).translate(\"2*y\"),\n    cone.pigment(Color(\"blue\")).scale(\"0.5*x\").translate(\"3*y\"),\n    cone.pigment(Color(\"yellow\")).scale(\"2*y\").translate(\"4.5*y\"),\n)\n</code></pre>"},{"location":"tutorial/object/transformations/#align_1","title":"Align","text":"<pre><code>render(\n    cone,\n    cone.pigment(Color(\"red\")).align([1, 0, 0]).translate(\"y\"),\n    cone.pigment(Color(\"green\")).align([0, 1, 0]).translate(\"2*y\"),\n    cone.pigment(Color(\"blue\")).align([0, 0, 1]).translate(\"4*y\"),\n    cone.pigment(Color(\"yellow\")).align([1, 1, 1]).translate(\"5*y\"),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/","title":"Finish","text":""},{"location":"tutorial/texture/finish/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(finish1, finish2, finish3):\n    checker = Pigment(\"checker\", Color(\"white\"), Color(\"gray\")).scale(0.1)\n    sphere = Sphere((0, 0, 0), 0.4, Color((1, 1, 0.5)))\n    return Scene(\n        Camera(0, 20, view_scale=1.2),\n        LightSource((1, 120, 45), \"white\"),\n        Plane((1, 0, 0), -0.5, checker),\n        Plane((0, 0, 1), -0.5, checker),\n        sphere.translate(0, -1, 0).add(finish1),\n        sphere.add(finish2),\n        sphere.translate(0, 1, 0).add(finish3),\n    ).render(600, 300)\n</code></pre>"},{"location":"tutorial/texture/finish/#ambient_1","title":"Ambient","text":"<pre><code>render(\n    Finish(ambient=0.1),  # default\n    Finish(ambient=0.3),\n    Finish(ambient=0.5),\n)\n</code></pre> <pre><code>render(\n    Finish(ambient=0.1),  # default\n    Finish(ambient=Color(\"red\")),\n    Finish(ambient=(0, 0, 1)),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#emission_1","title":"Emission","text":"<pre><code>render(\n    Finish(emission=0.1),  # defaut\n    Finish(emission=0.3),\n    Finish(emission=0.5),\n)\n</code></pre> <pre><code>render(\n    Finish(emission=0.1),  # defaut\n    Finish(emission=Color(\"red\")),\n    Finish(emission=(0, 0, 1)),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#diffuse_1","title":"Diffuse","text":"<pre><code>render(\n    Finish(diffuse=0.3),\n    Finish(diffuse=0.6),  # default\n    Finish(diffuse=0.9),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#brilliance_1","title":"Brilliance","text":"<pre><code>render(\n    Finish(brilliance=1),  # default\n    Finish(brilliance=3),\n    Finish(brilliance=5),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#phong_1","title":"Phong","text":"<pre><code>render(\n    Finish(phong=0),  # default\n    Finish(phong=0.3),\n    Finish(phong=1),\n)\n</code></pre> <pre><code>render(\n    Finish(phong=1, phong_size=20),\n    Finish(phong=1, phong_size=40),  # default\n    Finish(phong=1, phong_size=80),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#specular_1","title":"Specular","text":"<pre><code>render(\n    Finish(specular=0),  # default\n    Finish(specular=0.5),\n    Finish(specular=1),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#roughness_1","title":"Roughness","text":"<pre><code>render(\n    Finish(specular=1, roughness=0.01),\n    Finish(specular=1, roughness=0.05),  # default\n    Finish(specular=1, roughness=0.1),\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#metallic_1","title":"Metallic","text":"<pre><code>render(\n    Finish(specular=1, metallic=0),\n    Finish(specular=1, metallic=0.5),\n    Finish(specular=1, metallic=1),  # default\n)\n</code></pre>"},{"location":"tutorial/texture/finish/#reflection_1","title":"Reflection","text":"<pre><code>render(\n    Finish(reflection=0),  # default\n    Finish(reflection=0.3),\n    Finish(reflection=1),\n)\n</code></pre> <pre><code>render(\n    Finish(reflection=0),  # default\n    Finish(reflection=Color(\"red\")),\n    Finish(reflection=(0, 0, 1)),\n)\n</code></pre>"},{"location":"tutorial/texture/interior-texture/","title":"Interior Texture","text":"<pre><code>from fdray import *\n\nmaterial = Material(Texture(\"PinkAlabaster\"), InteriorTexture(\"Red_Marble\"))\n\nScene(\n    Include(\"textures.inc\"),\n    GlobalSettings(assumed_gamma=2.2),\n    Camera(45, 40, view_scale=7, look_at=(0, 0, 1), distance=15),\n    LightSource((0.3, 60, 80), \"white\"),\n    Plane(\"z\", 0, Pigment(\"checker\", Color(\"cyan\"), Color(\"white\"))),\n    Cylinder((0, 0, 0), (0, 0, 4), 4, \"open\", material),\n).render(600, 400)\n</code></pre>"},{"location":"tutorial/texture/normal/","title":"Normal","text":""},{"location":"tutorial/texture/normal/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(*attrs):\n    return Scene(\n        Include(\"colors.inc\", \"textures.inc\"),\n        Camera(0, 90, view_scale=1, look_at=(0.5, 1, 0)),\n        LightSource((2, 3, 4), \"white\", from_camera=False),\n        Box((0, 0, 0), (1, 2, 0.1), Texture(\"Chrome_Metal\", *attrs)),\n    ).render(400, 200)\n</code></pre>"},{"location":"tutorial/texture/normal/#slope-map_1","title":"Slope map","text":"<pre><code>smap = SlopeMap((0, (0, 0)), (0.5, (1, 1)), (0.5, (1, -1)), (1, (0, -1)))\nrender(Normal(\"wood\", smap).scale(0.5))\n</code></pre>"},{"location":"tutorial/texture/normal/#normal-map_1","title":"Normal map","text":"<pre><code>a = Normal(\"marble\", turbulence=0.4)\nb = Normal(\"facets\", coords=0.3, scale=0.3)\nn = Normal(\"gradient x\", NormalMap((0.2, a), (0.4, b), (0.6, b), (0.7, a)))\nrender(n.scale(0.4))\n</code></pre>"},{"location":"tutorial/texture/normal/#normal-pattern_1","title":"Normal pattern","text":"<pre><code>Scene(\n    Camera(30, 20, view_scale=1, look_at=(0.5, 0.5, 0.5)),\n    LightSource(0, \"white\"),\n    Box(0, 1).pigment(Color(\"white\")).normal(\"agate\"),\n).render(300, 300)\n</code></pre>"},{"location":"tutorial/texture/pattern/","title":"Pattern","text":""},{"location":"tutorial/texture/pattern/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(texture1, texture2):\n    sphere = Declare(Sphere(0, 1.2))\n    cylinder = Declare(Cylinder(\"-z\", \"z\", 1))\n    box = Declare(Box(-1, 1) - Box(-1, 1).translate(1))\n    shapes = Union(\n        Object(sphere).translate(\"-2.7*y\"),\n        Object(cylinder),\n        Object(box).translate(\"2.7*y\"),\n    )\n    return Scene(\n        Include(\"colors.inc\", \"textures.inc\", \"woods.inc\", \"stones.inc\", \"metals.inc\"),\n        Camera(10, 20, view_scale=4),\n        LightSource(0, \"white\"),\n        shapes.add(texture1).translate(\"1.5*z\"),\n        shapes.add(texture2).translate(\"-1.5*z\"),\n    ).render(800, 600)\n</code></pre>"},{"location":"tutorial/texture/pattern/#agate_1","title":"Agate","text":"<pre><code>render(Pigment(\"agate\").scale(0.8), [Color(\"White*0.9\"), Normal(\"agate\", 1).scale(0.8)])\n</code></pre>"},{"location":"tutorial/texture/pattern/#bumps_1","title":"Bumps","text":"<pre><code>render(\n    Pigment(\"bumps\", ColorMap((0, Color(\"blue\")), (0.5, Color(\"white\")))).scale(0.3),\n    [Color(\"White*0.9\"), Normal(\"bumps\", 1).scale(0.3)],\n)\n</code></pre>"},{"location":"tutorial/texture/pattern/#checker_1","title":"Checker","text":"<pre><code>render(\n    Pigment(\"checker\", Pigment(\"DMFWood4\"), Pigment(\"DMFWood1\")).scale(0.5),\n    Texture(\"checker\", Texture(\"Aluminum\"), Texture(\"T_Stone18\")).scale(0.5),\n)\n</code></pre>"},{"location":"tutorial/texture/pattern/#granite_1","title":"Granite","text":"<pre><code>render(Pigment(\"granite\"), [Color(\"White*0.9\"), Normal(\"granite\", 1)])\n</code></pre>"},{"location":"tutorial/texture/pattern/#marble_1","title":"Marble","text":"<pre><code>render(\n    Pigment(\"marble\", turbulence=0.8),\n    [Color(\"White*0.9\"), Normal(\"marble\", 1, turbulence=0.8)],\n)\n</code></pre>"},{"location":"tutorial/texture/pigment/","title":"Pigment","text":""},{"location":"tutorial/texture/pigment/#rendering-function","title":"Rendering function","text":"<pre><code>from fdray import *\n\n\ndef render(*attrs):\n    return Scene(\n        Camera(30, 20, view_scale=2),\n        LightSource(0, \"white\"),\n        Box((-1, -1, -1), (1, 1, 1), *attrs),\n    ).render(300, 300)\n</code></pre>"},{"location":"tutorial/texture/pigment/#solid-color","title":"Solid color","text":"<pre><code>render(Color(\"red\"))\n</code></pre>"},{"location":"tutorial/texture/pigment/#color-list","title":"Color list","text":""},{"location":"tutorial/texture/pigment/#brick","title":"Brick","text":"<pre><code>render(Pigment(\"brick\", Color(\"red\", 0.4), Color(\"blue\")).scale(0.2))\n</code></pre>"},{"location":"tutorial/texture/pigment/#checker","title":"Checker","text":"<pre><code>render(Pigment(\"checker\", Color(\"ivory\"), Color(\"cyan\")).scale(0.4))\n</code></pre>"},{"location":"tutorial/texture/pigment/#hexagon","title":"Hexagon","text":"<pre><code>render(\n    Pigment(\n        \"hexagon\",\n        Color(\"teal\"),\n        Color(\"navy\"),\n        Color(\"purple\"),\n    )\n    .scale(0.2)\n    .rotate(\"90*z\"),\n)\n</code></pre>"},{"location":"tutorial/texture/pigment/#color-map","title":"Color map","text":""},{"location":"tutorial/texture/pigment/#gradient","title":"Gradient","text":"<pre><code>cmap = ColorMap((0, Color(\"red\")), (0.5, Color(\"blue\")), (1, Color(\"red\")))\nrender(Pigment(\"gradient x\", cmap))\n</code></pre>"},{"location":"tutorial/texture/pigment/#checker_1","title":"Checker","text":"<pre><code>a = Pigment(\"granite\", ColorMap((0, Color(\"red\")), (0.9, Color(\"white\"))))\nb = Pigment(\"granite\", ColorMap((0, Color(\"blue\")), (0.9, Color(\"white\"))))\np = Pigment(\"checker\", a, b).scale(0.5)\nrender(p)\n</code></pre>"},{"location":"tutorial/texture/pigment/#pigment-map_1","title":"Pigment map","text":"<pre><code>p = Pigment(\"gradient z\", PigmentMap((0, a), (0.5, b), (1, a)))\nrender(p)\n</code></pre> <pre><code>a = Declare(Pigment(\"agate\", ColorMap((0, Color(\"red\")), (0.9, Color(\"white\")))))\nb = Declare(Pigment(\"agate\", ColorMap((0, Color(\"blue\")), (0.9, Color(\"white\")))))\np = Pigment(\"gradient x\", PigmentMap((0, a), (0.5, b), (1, a)))\nrender(p)\n</code></pre>"},{"location":"api/fdray/","title":"fdray","text":"fdray<p> source package fdray </p> <p> Classes </p> <ul> <li> <p>Background</p> </li> <li> <p>Box \u2014 A box defined by two corner points.</p> </li> <li> <p>Camera \u2014 A camera for viewing 3D scenes.</p> </li> <li> <p>Color \u2014 A color representation with support for POV-Ray color properties.</p> </li> <li> <p>ColorMap</p> </li> <li> <p>ColorName \u2014 Color name enumeration with hex values.</p> </li> <li> <p>Cone \u2014 A cone or truncated cone between two points with specified radii.</p> </li> <li> <p>Cube \u2014 A cube defined by a center point and edge length.</p> </li> <li> <p>Cuboid \u2014 A rectangular prism defined by a center point and dimensions.</p> </li> <li> <p>Curve \u2014 A smooth curve that passes through all specified points.</p> </li> <li> <p>Cylinder \u2014 A cylinder defined by two points and a radius.</p> </li> <li> <p>Declare</p> </li> <li> <p>Difference \u2014 Difference of shapes - points inside the first shape and outside all others.</p> </li> <li> <p>Finish \u2014 POV-Ray finish attributes.</p> </li> <li> <p>GlobalSettings</p> </li> <li> <p>Include</p> </li> <li> <p>Interior \u2014 POV-Ray interior descriptor.</p> </li> <li> <p>InteriorTexture</p> </li> <li> <p>Intersection \u2014 Intersection of shapes - points inside all shapes are inside the intersection.</p> </li> <li> <p>LightSource</p> </li> <li> <p>Material \u2014 Materials define the appearance of objects in the scene.</p> </li> <li> <p>Merge \u2014 Merge of shapes - similar to union but with different surface calculations.</p> </li> <li> <p>Normal</p> </li> <li> <p>NormalMap</p> </li> <li> <p>Object \u2014 Base class for all 3D objects.</p> </li> <li> <p>Pigment</p> </li> <li> <p>PigmentMap</p> </li> <li> <p>Plane \u2014 A plane defined by a normal vector and distance from origin.</p> </li> <li> <p>Polyline \u2014 A polyline (broken line) represented as a linear sphere sweep.</p> </li> <li> <p>Renderer</p> </li> <li> <p>Scene \u2014 A scene is a collection of elements.</p> </li> <li> <p>SkySphere \u2014 A sky sphere that defines the background color of the scene.</p> </li> <li> <p>SlopeMap</p> </li> <li> <p>Sphere \u2014 A sphere defined by a center point and radius.</p> </li> <li> <p>SphereSweep \u2014 A sweep of spheres along a path with specified interpolation.</p> </li> <li> <p>Spotlight</p> </li> <li> <p>Text \u2014 A text object defined by a string and a font.</p> </li> <li> <p>Texture</p> </li> <li> <p>Torus \u2014 A torus defined by a center point and a radius.</p> </li> <li> <p>Transform \u2014 POV-Ray transformation descriptor.</p> </li> <li> <p>Union</p> </li> <li> <p>Vector</p> </li> </ul> <p> source class Background(color: ColorLike, alpha: float | None = None, *, filter: float | None = None, transmit: float | None = None) </p> <p>Bases : Color</p> <p> source class Box(corner1: Point, corner2: Point, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A box defined by two corner points.</p> <p>A box is an axis-aligned rectangular prism defined by two opposite corners.</p> <p> Parameters </p> <ul> <li> <p>corner1 :  Point \u2014 First corner point.</p> </li> <li> <p>corner2 :  Point \u2014 Second corner point (diagonally opposite to corner1).</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source dataclass Camera(longitude: InitVar[float] = 0, latitude: InitVar[float] = 0, view_scale: float = 1, distance: float = 0, tilt: float = 0, look_at: tuple[float, float, float] = (0, 0, 0), aspect_ratio: float = 4 / 3) </p> <p>Bases : Descriptor</p> <p>A camera for viewing 3D scenes.</p> <p>Define the viewpoint and projection for a 3D scene. The camera position is specified using spherical coordinates, and various parameters allow adjusting the field of view and perspective effects.</p> <p> Attributes </p> <ul> <li> <p>longitude :  InitVar[float] \u2014 The longitude of the camera in degrees.</p> </li> <li> <p>latitude :  InitVar[float] \u2014 The latitude of the camera in degrees.</p> </li> <li> <p>view_scale :  float \u2014 The scale of the view frustum, controlling how much of the scene is visible.</p> </li> <li> <p>distance :  float \u2014 The distance of the camera from the look_at point.</p> </li> <li> <p>tilt :  float \u2014 The tilt angle of the camera in degrees (-180 to 180).</p> </li> <li> <p>look_at :  tuple[float, float, float] \u2014 The point the camera is looking at.</p> </li> <li> <p>aspect_ratio :  float \u2014 The aspect ratio of the camera.</p> </li> <li> <p>phi :  float \u2014 Internal storage for longitude in radians.</p> </li> <li> <p>theta :  float \u2014 Internal storage for latitude in radians.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>orbital_location \u2014 Calculate a position in orbit around the camera's location.</p> </li> </ul> <p> source property Camera.z: Vector </p> <p> source property Camera.x: Vector </p> <p> source property Camera.y: Vector </p> <p> source property Camera.direction: Vector </p> <p> source property Camera.location: Vector </p> <p> source property Camera.right: Vector </p> <p> source property Camera.up: Vector </p> <p> source property Camera.sky: Vector </p> <p> source method Camera.orbital_location(forward: float = 0, angle: float = 0, rotation: float = 0) \u2192 Vector </p> <p>Calculate a position in orbit around the camera's location.</p> <p>Imagine tilting your head up (angle) and then rotating counter-clockwise (rotation):</p> <ul> <li>First, move forward along viewing direction (0=at <code>camera.location</code>,   1=at <code>camera.look_at</code>). Negative values move behind the camera.</li> <li>Then, tilt up from viewing direction by 'angle' degrees</li> <li>Finally, rotate counter-clockwise from up by 'rotation' degrees   (0=up, 90=left, 180=down, 270=right)</li> </ul> <p> Parameters </p> <ul> <li> <p>forward :  float \u2014 Relative position along viewing direction (0=camera, 1=look_at, negative=behind camera)</p> </li> <li> <p>angle :  float \u2014 Tilt angle from viewing direction in degrees</p> </li> <li> <p>rotation :  float \u2014 Rotation angle from up direction in degrees (counter-clockwise)</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Vector \u2014 Position vector in absolute coordinates</p> </li> </ul> <p> source class Color(color: ColorLike, alpha: float | None = None, *, filter: float | None = None, transmit: float | None = None) </p> <p>A color representation with support for POV-Ray color properties.</p> <p>This class handles various color formats and provides conversion to POV-Ray SDL syntax. Colors can be specified by name, hex code (including #RRGGBBAA format), RGB or RGBA tuple, or by copying another Color object. Optional properties include alpha transparency, filter, and transmit values.</p> <p> Parameters </p> <ul> <li> <p>color :  ColorLike \u2014 Color specification. Can be:</p> <ul> <li>A Color object</li> <li>String name (e.g., \"red\")</li> <li>Hex code (e.g., \"#00FF00\" or \"#00FF00FF\" with alpha)</li> <li>RGB tuple (e.g., (1.0, 0.0, 0.0))</li> <li>RGBA tuple (e.g., (1.0, 0.0, 0.0, 0.5))</li> </ul> </li> <li> <p>alpha :  float | None \u2014 Alpha transparency (0.0 = fully transparent, 1.0 = fully opaque). If provided, converts to transmit value (transmit = 1 - alpha). Takes precedence over alpha in RGBA tuple or hex code.</p> </li> <li> <p>filter :  float | None \u2014 Filter property for POV-Ray (how much color filters through). Only used when specified as a keyword argument.</p> </li> <li> <p>transmit :  float | None \u2014 Transmit property for POV-Ray (how much light passes through). Only used when specified as a keyword argument.</p> </li> <li> <p>include_color \u2014 Whether to include the \"color\" keyword in string output. Defaults to True.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>red :  float \u2014 Red component (0.0 to 1.0)</p> </li> <li> <p>green :  float \u2014 Green component (0.0 to 1.0)</p> </li> <li> <p>blue :  float \u2014 Blue component (0.0 to 1.0)</p> </li> <li> <p>name :  str | None \u2014 Color name if created from a named color</p> </li> <li> <p>filter :  float | None \u2014 Filter property (how much color filters through)</p> </li> <li> <p>transmit :  float | None \u2014 Transmit property (how much light passes through)</p> </li> <li> <p>include_color :  bool \u2014 Whether to include \"color\" keyword in output</p> </li> </ul> <p> Examples </p> <pre><code>Color(\"red\")\nColor((1.0, 0.0, 0.0))\nColor((1.0, 0.0, 0.0, 0.5))  # RGBA with alpha=0.5\nColor(\"blue\", alpha=0.5)\nColor(\"#00FF00\", filter=0.3)\nColor(\"#00FF00FF\")  # Hex color with alpha\nColor(existing_color, transmit=0.7)\n</code></pre> <p> Methods </p> <ul> <li> <p>from_direction \u2014 Create a color from a direction vector.</p> </li> </ul> <p> source classmethod Color.from_direction(direction: Sequence[float], axis: int = 2) \u2192 Self </p> <p>Create a color from a direction vector.</p> <p> Parameters </p> <ul> <li> <p>direction :  Sequence[float] \u2014 The direction vector to colorize.</p> </li> <li> <p>axis :  int \u2014 The axis to colorize.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Color \u2014 The color corresponding to the direction vector.</p> </li> </ul> <p> source class ColorMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source class ColorName() </p> <p>Color name enumeration with hex values.</p> <p> source class Cone(center1: Point, radius1: float, center2: Point, radius2: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A cone or truncated cone between two points with specified radii.</p> <p> Parameters </p> <ul> <li> <p>center1 :  Point \u2014 Center of the first end.</p> </li> <li> <p>radius1 :  float \u2014 Radius of the first end.</p> </li> <li> <p>center2 :  Point \u2014 Center of the second end.</p> </li> <li> <p>radius2 :  float \u2014 Radius of the second end.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cube(center: float | Sequence[float] | Vector = 0, size: float = 1, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A cube defined by a center point and edge length.</p> <p>This is a convenience class that creates a Box representing a cube.</p> <p> Parameters </p> <ul> <li> <p>center :  float | Sequence[float] | Vector \u2014 Center point of the cube.</p> </li> <li> <p>size :  float \u2014 Edge length of the cube.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cuboid(center: float | Sequence[float] | Vector, size: float | Sequence[float] | Vector, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A rectangular prism defined by a center point and dimensions.</p> <p>This is a convenience class that creates a Box centered at a specified point.</p> <p> Parameters </p> <ul> <li> <p>center :  float | Sequence[float] | Vector \u2014 Center point of the cuboid.</p> </li> <li> <p>size :  float | Sequence[float] | Vector \u2014 Dimensions (width, height, depth) of the cuboid.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Curve(centers: Sequence[Point] | NDArray[np.number], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) </p> <p>Bases : Polyline</p> <p>A smooth curve that passes through all specified points.</p> <p>Create a cubic spline sphere sweep that is guaranteed to pass through all given points, including the start and end points. It uses ghost points to ensure proper curve behavior at the endpoints.</p> <p>Unlike standard cubic splines which may not pass through the endpoints, this implementation ensures the curve follows all specified points exactly.</p> <p> Parameters </p> <ul> <li> <p>centers :  Sequence[Point] | NDArray[np.number] \u2014 Sequence of 3D points or NumPy array with shape (n, 3) where n is the number of points.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each point.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cylinder(center1: Point, center2: Point, radius: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A cylinder defined by two points and a radius.</p> <p> Parameters </p> <ul> <li> <p>center1 :  Point \u2014 Center of the first end.</p> </li> <li> <p>center2 :  Point \u2014 Center of the second end.</p> </li> <li> <p>radius :  float \u2014 Radius of the cylinder.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Declare(value: Any, name: str | None = None) </p> <p> Methods </p> <ul> <li> <p>clear \u2014 Clear the members.</p> </li> <li> <p>add</p> </li> <li> <p>to_str</p> </li> <li> <p>iter_strs</p> </li> </ul> <p> source classmethod Declare.clear() \u2192 None </p> <p>Clear the members.</p> <p> source classmethod Declare.add(member: Self) \u2192 None </p> <p> source method Declare.to_str() \u2192 str </p> <p> source classmethod Declare.iter_strs() \u2192 Iterator[str] </p> <p> source class Difference(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Difference of shapes - points inside the first shape and outside all others.</p> <p>A difference represents the boolean subtraction operation on shapes.</p> <p> source dataclass Finish(ambient: float | ColorLike | None = None, emission: float | ColorLike | None = None, diffuse: float | None = None, brilliance: float | None = None, phong: float | None = None, phong_size: float | None = None, specular: float | None = None, roughness: float | None = None, metallic: float | None = None, reflection: float | ColorLike | None = None) </p> <p>Bases : Descriptor</p> <p>POV-Ray finish attributes.</p> <p> source dataclass GlobalSettings(ambient_light: ColorLike | None = None, assumed_gamma: float = 1) </p> <p>Bases : Descriptor</p> <p> source class Include(*filenames: str) </p> <p> source dataclass Interior(ior: float | None = None, caustics: float | None = None, dispersion: float | None = None, dispersion_samples: int | None = None, fade_distance: float | None = None, fade_power: float | None = None, fade_color: ColorLike | None = None) </p> <p>Bases : Descriptor</p> <p>POV-Ray interior descriptor.</p> <p> source class InteriorTexture(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> source class Intersection(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Intersection of shapes - points inside all shapes are inside the intersection.</p> <p>An intersection represents the boolean AND operation on shapes.</p> <p> source dataclass LightSource(location: Point, color: ColorLike | None = None, from_camera: bool = True, shadowless: bool = False, fade_distance: float | None = None, fade_power: float | None = None) </p> <p>Bases : Descriptor</p> <p> Methods </p> <ul> <li> <p>to_str</p> </li> </ul> <p> source property LightSource.name: str </p> <p> source method LightSource.to_str(camera: Camera | None) \u2192 str </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source class Material(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p>Materials define the appearance of objects in the scene.</p> <p> source class Merge(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Merge of shapes - similar to union but with different surface calculations.</p> <p>A merge represents a union where internal surfaces are removed.</p> <p> source class Normal(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> source class NormalMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source class Object(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p>Base class for all 3D objects.</p> <p>This class defines common behavior for all objects including:</p> <ul> <li>String serialization to POV-Ray SDL format</li> <li>CSG operations (union, intersection, difference, merge)</li> <li>Transformations (scale, rotate, translate)</li> <li>Attribute handling</li> </ul> <p> Attributes </p> <ul> <li> <p>nargs :  ClassVar[int] \u2014 Number of required arguments for this object.</p> </li> <li> <p>args :  list[Any] \u2014 List of positional arguments passed to the object.</p> </li> <li> <p>attrs :  list[Any] \u2014 List of object attributes (pigment, texture, etc.).</p> </li> </ul> <p> Methods </p> <ul> <li> <p>texture \u2014 Add a texture to the object.</p> </li> <li> <p>pigment \u2014 Add a pigment to the object.</p> </li> <li> <p>normal \u2014 Add a normal to the object.</p> </li> <li> <p>finish \u2014 Add a finish to the object.</p> </li> <li> <p>interior \u2014 Add an interior to the object.</p> </li> <li> <p>material \u2014 Add a material to the object.</p> </li> </ul> <p> source method Object.texture(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a texture to the object.</p> <p> source method Object.pigment(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a pigment to the object.</p> <p> source method Object.normal(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a normal to the object.</p> <p> source method Object.finish(ambient: float | ColorLike | None = None, emission: float | ColorLike | None = None, diffuse: float | None = None, brilliance: float | None = None, phong: float | None = None, phong_size: float | None = None, specular: float | None = None, roughness: float | None = None, metallic: float | None = None, reflection: float | ColorLike | None = None) \u2192 Self </p> <p>Add a finish to the object.</p> <p> source method Object.interior(ior: float | None = None, caustics: float | None = None, dispersion: float | None = None, dispersion_samples: int | None = None, fade_distance: float | None = None, fade_power: float | None = None, fade_color: ColorLike | None = None) \u2192 Self </p> <p>Add an interior to the object.</p> <p> source method Object.material(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a material to the object.</p> <p> source class Pigment(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> Methods </p> <ul> <li> <p>uv_mapping \u2014 Create a UV mapping pigment from image data.</p> </li> </ul> <p> source classmethod Pigment.uv_mapping(data: str | Path | NDArray[Any] | Image, interpolate: int = 2) \u2192 Self </p> <p>Create a UV mapping pigment from image data.</p> <p> Parameters </p> <ul> <li> <p>data :  str | Path | NDArray | Image \u2014 The image data. Can be a file path, NumPy array, or PIL Image.</p> </li> <li> <p>interpolate :  int, optional \u2014 The interpolation method. Defaults to 2. 0: none, 1: linear, 2: bilinear, 3: trilinear, 4: bicubic.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 A Pigment instance with UV mapping.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError \u2014 If the image file does not exist.</p> </li> <li> <p>ValueError \u2014 If the interpolation value is invalid.</p> </li> </ul> <p> source class PigmentMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source class Plane(normal: Point, distance: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A plane defined by a normal vector and distance from origin.</p> <p> Parameters </p> <ul> <li> <p>normal :  Point \u2014 Normal vector of the plane.</p> </li> <li> <p>distance :  float \u2014 Distance from the origin along the normal.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Polyline(centers: Sequence[Point] | NDArray[np.number], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A polyline (broken line) represented as a linear sphere sweep.</p> <p>This is a convenience class that creates a sphere sweep with <code>linear_spline</code> interpolation, providing a simpler interface for creating polylines.</p> <p> Parameters </p> <ul> <li> <p>centers :  Sequence[Point] | NDArray[np.number] \u2014 Sequence of 3D points or NumPy array with shape (n, 3) where n is the number of points.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each point.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_coordinates \u2014 Create a polyline from separate x, y, z coordinate sequences.</p> </li> </ul> <p> source classmethod Polyline.from_coordinates(x: Sequence[float], y: Sequence[float], z: Sequence[float], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) \u2192 Self </p> <p>Create a polyline from separate x, y, z coordinate sequences.</p> <p> Parameters </p> <ul> <li> <p>x :  Sequence[float] \u2014 Sequence of x-coordinates.</p> </li> <li> <p>y :  Sequence[float] \u2014 Sequence of y-coordinates.</p> </li> <li> <p>z :  Sequence[float] \u2014 Sequence of z-coordinates.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each point.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 New Polyline instance.</p> </li> </ul> <p> source class Renderer(width: int | None = None, height: int | None = None, output_alpha: bool | None = None, quality: int | None = None, antialias: bool | float | None = None, threads: int | None = None, display: bool | None = None) </p> <p> Methods </p> <ul> <li> <p>build \u2014 Build the command line arguments for the POV-Ray renderer.</p> </li> <li> <p>render \u2014 Render a POV-Ray scene.</p> </li> </ul> <p> source method Renderer.build(scene: str, output_file: str | Path | None = None) \u2192 list[str] </p> <p>Build the command line arguments for the POV-Ray renderer.</p> <p> Parameters </p> <ul> <li> <p>scene :  str \u2014 The scene description.</p> </li> <li> <p>output_file :  str | Path | None \u2014 The output file path.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[str] \u2014 The command line arguments.</p> </li> </ul> <p> source method Renderer.render(scene: Any, output_file: str | Path | None = None, *, return_image: bool = False, trim: bool | int = False) \u2192 NDArray[np.uint8] | Image.Image | None </p> <p>Render a POV-Ray scene.</p> <p> Parameters </p> <ul> <li> <p>scene :  Any \u2014 POV-Ray scene description output_file: Output image file path.     If None, returns a numpy array instead of saving to file. return_image: If True, returns a PIL image instead of a numpy array. trim: If True, trim the output image to the non-transparent region.</p> </li> <li> <p>Returns \u2014 NDArray[np.uint8] | Image.Image | None: RGB(A) image array or PIL image if output_file is None</p> </li> </ul> <p> Raises </p> <ul> <li> <p>RenderError</p> </li> </ul> <p> source class Scene(*attrs: Any) </p> <p>A scene is a collection of elements.</p> <p> Methods </p> <ul> <li> <p>set</p> </li> <li> <p>copy</p> </li> <li> <p>add</p> </li> <li> <p>to_str \u2014 Create a string representation of the scene with the given image dimensions.</p> </li> <li> <p>render \u2014 Render the scene with the given image dimensions.</p> </li> </ul> <p> source method Scene.set(*attrs: Any) \u2192 Self </p> <p> source method Scene.copy() \u2192 Self </p> <p> source method Scene.add(*attrs: Any) \u2192 Self </p> <p> source method Scene.to_str(width: int, height: int) \u2192 str </p> <p>Create a string representation of the scene with the given image dimensions.</p> <p> Parameters </p> <ul> <li> <p>width :  int \u2014 The width of the image.</p> </li> <li> <p>height :  int \u2014 The height of the image.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A string representation of the scene.</p> </li> </ul> <p> source method Scene.render(width: int | None = None, height: int | None = None, output_alpha: bool | None = None, quality: int | None = None, antialias: bool | float | None = None, threads: int | None = None, *, trim: bool | int = False) \u2192 Image.Image </p> <p>Render the scene with the given image dimensions.</p> <p> Parameters </p> <ul> <li> <p>width :  int | None \u2014 The width of the image.</p> </li> <li> <p>height :  int | None \u2014 The height of the image.</p> </li> <li> <p>output_alpha :  bool | None \u2014 If True, output an image with an alpha channel.</p> </li> <li> <p>quality :  int | None \u2014 The quality of the image.</p> </li> <li> <p>antialias :  bool | float | None \u2014 The antialiasing level.</p> </li> <li> <p>threads :  int | None \u2014 The number of threads to use.</p> </li> <li> <p>trim :  bool | int \u2014 If True, trim the output image to the non-transparent region. If an integer, trim the output image to the non-transparent region by the given margin.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Image.Image \u2014 The rendered image.</p> </li> </ul> <p> source class SkySphere(*args: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A sky sphere that defines the background color of the scene.</p> <p> source class SlopeMap(*args: tuple[float, Sequence[float]]) </p> <p>Bases : Map</p> <p> source class Sphere(center: Point = 0, radius: float = 1, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A sphere defined by a center point and radius.</p> <p> Parameters </p> <ul> <li> <p>center :  Point \u2014 Center point of the sphere.</p> </li> <li> <p>radius :  float \u2014 Radius of the sphere.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class SphereSweep(kind: Literal['linear_spline', 'b_spline', 'cubic_spline'], centers: Sequence[Point], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A sweep of spheres along a path with specified interpolation.</p> <p>SphereSweep creates a smooth shape passing through a series of spheres using different interpolation methods.</p> <p> Parameters </p> <ul> <li> <p>kind :  Literal['linear_spline', 'b_spline', 'cubic_spline'] \u2014 Interpolation method for the sweep.</p> </li> <li> <p>centers :  Sequence[Point] \u2014 Sequence of center points for the spheres.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each sphere.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source dataclass Spotlight(location: Point, color: ColorLike | None = None, from_camera: bool = True, shadowless: bool = False, fade_distance: float | None = None, fade_power: float | None = None, spotlight: bool = True, radius: float | None = None, falloff: float | None = None, tightness: float | None = None, point_at: Point | None = None) </p> <p>Bases : LightSource</p> <p> source class Text(text: str, thickness: float = 0, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A text object defined by a string and a font.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The text string to display.</p> </li> <li> <p>font \u2014 The font to use for the text.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>align \u2014 Align the text with the given longitude and latitude.</p> </li> <li> <p>set_font \u2014 Set the font file for the text object.</p> </li> </ul> <p> source method Text.align(longitude: float = 0, latitude: float = 0) \u2192 Self </p> <p>Align the text with the given longitude and latitude.</p> <p> Parameters </p> <ul> <li> <p>longitude :  float \u2014 The longitude of the text.</p> </li> <li> <p>latitude :  float \u2014 The latitude of the text.</p> </li> </ul> <p> source classmethod Text.set_font(font_spec: str | Path) \u2192 str | None </p> <p>Set the font file for the text object.</p> <p>This method determines how to handle the font specification based on its format:</p> <ul> <li>If <code>font_spec</code> ends with '.ttf', it's treated as a direct file path.</li> <li>Otherwise, it's treated as a font name to search in system fonts.</li> </ul> <p> Parameters </p> <ul> <li> <p>font_spec :  str | Path \u2014 Font specification, either a path to a TTF file or a font name. If it's a font name, the method will search for matching fonts in the system fonts directory.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 Path to the font file if found, None otherwise.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ImportError \u2014 If matplotlib is not installed and a font name search is attempted.</p> </li> </ul> <p> source class Texture(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> source class Torus(major_radius: float, minor_radius: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A torus defined by a center point and a radius.</p> <p> Parameters </p> <ul> <li> <p>major_radius :  float \u2014 Major radius of the torus.</p> </li> <li> <p>minor_radius :  float \u2014 Minor radius of the torus.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source dataclass Transform(scale: Point | None = None, rotate: Point | None = None, translate: Point | None = None) </p> <p>Bases : Descriptor</p> <p>POV-Ray transformation descriptor.</p> <p> source class Union(*args: Any, **kwargs: Any) </p> <p>Bases : BaseUnion</p> <p> Methods </p> <ul> <li> <p>from_field \u2014 Create objects from scalar, vector or tensor fields.</p> </li> <li> <p>from_region \u2014 Create objects from a discrete region.</p> </li> </ul> <p> source classmethod Union.from_field(field: Sequence[Any] | NDArray[Any], obj: Callable[[Any], Object | Iterable[Object] | None], spacing: float | tuple[float, ...] = 1, ndim: int = 1, mask: Sequence[Any] | NDArray[Any] | None = None, *, as_union: bool = True) \u2192 Self | list[Object] </p> <p>Create objects from scalar, vector or tensor fields.</p> <p>This function generates 3D objects from field data. The last <code>ndim</code> dimensions of the input array are considered as field components.</p> <p> Parameters </p> <ul> <li> <p>field :  Sequence | NDArray \u2014 Array containing field data</p> </li> <li> <p>obj :  Callable[[Any], Object | Iterable[Object] | None] \u2014 Function that takes field data at a position and returns an Object (or None to skip)</p> </li> <li> <p>spacing :  float | tuple[float, ...] \u2014 Distance between objects (scalar or per-dimension)</p> </li> <li> <p>ndim :  int \u2014 Number of dimensions to treat as field components:</p> <ul> <li>ndim=0: Scalar field (all dimensions used for positioning)</li> <li>ndim=1: Vector field (last dimension contains vector components)</li> <li>ndim=2: Tensor field (last two dimensions contain tensor components)</li> </ul> </li> <li> <p>mask :  Sequence | NDArray | None \u2014 Boolean mask to filter field data</p> </li> <li> <p>as_union :  bool \u2014 Whether to return a Union object or a list of objects</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self | list[Object] \u2014 Union object or list of objects representing the field</p> </li> </ul> <p> source classmethod Union.from_region(region: Sequence[Any] | NDArray[Any], obj: Object | Callable[[Any], Object | Iterable[Object] | None] | None = None, spacing: float | tuple[float, ...] = 1, mapping: Mapping[Any, Any] | None = None, *, as_union: bool = True) \u2192 Self | list[Object] </p> <p>Create objects from a discrete region.</p> <p>This function generates 3D objects from a discrete region, where each unique value in the region corresponds to an object with specific attributes.</p> <p>The function supports two modes:</p> <ol> <li>Base object + attribute mapping: Provide an Object instance and a mapping of region values to attributes (e.g., colors).</li> <li>Custom object generation: Provide a callback function that takes a region value and returns an Object (similar to from_field).</li> </ol> <p> Parameters </p> <ul> <li> <p>region :  Sequence | NDArray \u2014 Array containing region data (discrete values)</p> </li> <li> <p>obj :  Object | Callable[[Any], Object | Iterable[Object] | None] | None \u2014 Either an Object instance to be used as base, or a function that takes a region value and returns an Object, or None to use a default Cube</p> </li> <li> <p>spacing :  float | tuple[float, ...] \u2014 Distance between objects (scalar or per-dimension)</p> </li> <li> <p>mapping :  Mapping[Any, Any] | None \u2014 Mapping from region values to attributes (used only when obj is an Object)</p> </li> <li> <p>as_union :  bool \u2014 Whether to return a Union object or a list of objects</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self | list[Object] \u2014 Union object or list of objects representing the region</p> </li> </ul> <p> source class Vector(x: float | Iterable[float], y: float | None = None, z: float | None = None) </p> <p> Methods </p> <ul> <li> <p>norm</p> </li> <li> <p>normalize \u2014 Normalize the vector to unit length.</p> </li> <li> <p>dot \u2014 Compute the dot product of two vectors.</p> </li> <li> <p>cross \u2014 Compute the cross product of two vectors.</p> </li> <li> <p>rotate \u2014 Rotate a vector around an axis by an angle (Rodrigues' rotation formula).</p> </li> <li> <p>reflect \u2014 Reflect this vector across another vector.</p> </li> <li> <p>angle \u2014 Calculate angle between two vectors in radians.</p> </li> <li> <p>from_spherical \u2014 Create a vector from spherical coordinates.</p> </li> <li> <p>to_spherical \u2014 Convert vector to spherical coordinates.</p> </li> </ul> <p> source method Vector.norm() \u2192 float </p> <p> source method Vector.normalize() \u2192 Self </p> <p>Normalize the vector to unit length.</p> <p> Returns </p> <ul> <li> <p>Self \u2014 The normalized vector.</p> </li> </ul> <p> source method Vector.dot(other: Vector | Iterable[float]) \u2192 float </p> <p>Compute the dot product of two vectors.</p> <p> Parameters </p> <ul> <li> <p>other :  Vector | Iterable[float] \u2014 The vector to dot with</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 The dot product of the two vectors.</p> </li> </ul> <p> source method Vector.cross(other: Vector | Iterable[float]) \u2192 Self </p> <p>Compute the cross product of two vectors.</p> <p> Parameters </p> <ul> <li> <p>other :  Vector | Iterable[float] \u2014 The vector to cross with</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 The cross product of the two vectors.</p> </li> </ul> <p> source method Vector.rotate(axis: Vector | Iterable[float], theta: float) \u2192 Self </p> <p>Rotate a vector around an axis by an angle (Rodrigues' rotation formula).</p> <p> Parameters </p> <ul> <li> <p>axis :  Vector | Iterable[float] \u2014 The axis of rotation (will be normalized).</p> </li> <li> <p>theta :  float \u2014 The angle of rotation in radians.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Vector \u2014 The rotated vector.</p> </li> </ul> <p> source method Vector.reflect(across: Vector | Iterable[float]) \u2192 Self </p> <p>Reflect this vector across another vector.</p> <p> Parameters </p> <ul> <li> <p>across :  Vector | Iterable[float] \u2014 The vector to reflect across</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 The reflected vector</p> </li> </ul> <p> source method Vector.angle(other: Vector | Iterable[float]) \u2192 float </p> <p>Calculate angle between two vectors in radians.</p> <p> Parameters </p> <ul> <li> <p>other :  Vector | Iterable[float] \u2014 Another vector to calculate angle with</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 Angle between vectors in radians (0-\u03c0)</p> </li> </ul> <p> source classmethod Vector.from_spherical(phi: float, theta: float) \u2192 Self </p> <p>Create a vector from spherical coordinates.</p> <p> Parameters </p> <ul> <li> <p>phi :  float \u2014 azimuthal angle in radians (-\u03c0 to \u03c0 or 0 to 2\u03c0) 0 on x-axis, \u03c0/2 on y-axis</p> </li> <li> <p>theta :  float \u2014 polar angle in radians (-\u03c0/2 to \u03c0/2) 0 at equator, \u03c0/2 at north pole, -\u03c0/2 at south pole</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Vector \u2014 unit vector (x, y, z) where:     x = cos(\u03b8)cos(\u03c6)     y = cos(\u03b8)sin(\u03c6)     z = sin(\u03b8)</p> </li> </ul> <p> source method Vector.to_spherical() \u2192 tuple[float, float] </p> <p>Convert vector to spherical coordinates.</p> <p> Returns </p> <ul> <li> <p>tuple[float, float] \u2014 A tuple of (phi, theta) where</p> <ul> <li>phi: azimuthal angle in radians (-\u03c0 to \u03c0),   0 on x-axis, \u03c0/2 on y-axis</li> <li>theta: polar angle in radians (-\u03c0/2 to \u03c0/2),   0 at equator, \u03c0/2 at north pole, -\u03c0/2 at south pole</li> </ul> </li> </ul>"},{"location":"api/fdray/core/","title":"fdray.core","text":"fdray.core<p> source package fdray.core </p> <p> Modules </p> <ul> <li> <p>fdray.core.base</p> </li> <li> <p>fdray.core.camera \u2014 The camera implementation.</p> </li> <li> <p>fdray.core.color \u2014 Color definitions and utilities for ray tracing.</p> </li> <li> <p>fdray.core.light_source</p> </li> <li> <p>fdray.core.media</p> </li> <li> <p>fdray.core.object \u2014 3D objects and operations for ray tracing.</p> </li> <li> <p>fdray.core.renderer</p> </li> <li> <p>fdray.core.scene</p> </li> <li> <p>fdray.core.texture</p> </li> </ul>"},{"location":"api/fdray/core/base/","title":"fdray.core.base","text":"fdray.core.base<p> source module fdray.core.base </p> <p> Classes </p> <ul> <li> <p>Base</p> </li> <li> <p>Attribute</p> </li> <li> <p>Element</p> </li> <li> <p>Map</p> </li> <li> <p>IdGenerator \u2014 Generate unique identifiers for objects.</p> </li> <li> <p>Declare</p> </li> <li> <p>Descriptor</p> </li> <li> <p>Transform \u2014 POV-Ray transformation descriptor.</p> </li> <li> <p>Transformable</p> </li> </ul> <p> source class Base() </p> <p> source property Base.name: str </p> <p> source dataclass Attribute(name: str, value: Any) </p> <p> source class Element(*args: Any, **kwargs: Any) </p> <p>Bases : Base</p> <p> Methods </p> <ul> <li> <p>add</p> </li> </ul> <p> source method Element.add(*args: Any, **kwargs: Any) \u2192 Self </p> <p> source class Map(*args: Iterable[Any]) </p> <p>Bases : Base</p> <p> source class IdGenerator() </p> <p>Generate unique identifiers for objects.</p> <p> Methods </p> <ul> <li> <p>clear \u2014 Clear the counters.</p> </li> <li> <p>generate \u2014 Generate a unique identifier for an object.</p> </li> </ul> <p> source classmethod IdGenerator.clear() \u2192 None </p> <p>Clear the counters.</p> <p> source classmethod IdGenerator.generate(value: Any, name: str | None = None) \u2192 str </p> <p>Generate a unique identifier for an object.</p> <p> source class Declare(value: Any, name: str | None = None) </p> <p> Methods </p> <ul> <li> <p>clear \u2014 Clear the members.</p> </li> <li> <p>add</p> </li> <li> <p>to_str</p> </li> <li> <p>iter_strs</p> </li> </ul> <p> source classmethod Declare.clear() \u2192 None </p> <p>Clear the members.</p> <p> source classmethod Declare.add(member: Self) \u2192 None </p> <p> source method Declare.to_str() \u2192 str </p> <p> source classmethod Declare.iter_strs() \u2192 Iterator[str] </p> <p> source dataclass Descriptor() </p> <p>Bases : Base</p> <p> Methods </p> <ul> <li> <p>set \u2014 A context manager to set attributes.</p> </li> </ul> <p> source method Descriptor.set(**kwargs: Any) \u2192 Iterator[None] </p> <p>A context manager to set attributes.</p> <p> source dataclass Transform(scale: Point | None = None, rotate: Point | None = None, translate: Point | None = None) </p> <p>Bases : Descriptor</p> <p>POV-Ray transformation descriptor.</p> <p> source class Transformable(*args: Any, **kwargs: Any) </p> <p>Bases : Element</p> <p> Methods </p> <ul> <li> <p>scale \u2014 Scale the object uniformly or non-uniformly.</p> </li> <li> <p>rotate \u2014 Rotate the object around the x, y, and z axes.</p> </li> <li> <p>translate \u2014 Translate the object along the x, y, and z axes.</p> </li> <li> <p>align</p> </li> </ul> <p> source method Transformable.scale(x: float | str, y: float | None = None, z: float | None = None) \u2192 Self </p> <p>Scale the object uniformly or non-uniformly.</p> <p> Parameters </p> <ul> <li> <p>x :  float | str \u2014 Scale factor. If y and z are None, scales uniformly.</p> </li> <li> <p>y :  float | None \u2014 Scale factor for y-axis. If None, uses x for uniform scaling.</p> </li> <li> <p>z :  float | None \u2014 Scale factor for z-axis. If None, uses x for uniform scaling.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 New object with the scaling transformation applied.</p> </li> </ul> <p> source method Transformable.rotate(x: float | str, y: float | None = None, z: float | None = None) \u2192 Self </p> <p>Rotate the object around the x, y, and z axes.</p> <p> Parameters </p> <ul> <li> <p>x :  float | str \u2014 Rotation angle in degrees around the x-axis.</p> </li> <li> <p>y :  float | None \u2014 Rotation angle in degrees around the y-axis.</p> </li> <li> <p>z :  float | None \u2014 Rotation angle in degrees around the z-axis.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 New object with the rotation transformation applied.</p> </li> </ul> <p> source method Transformable.translate(x: float | str, y: float | None = None, z: float | None = None) \u2192 Self </p> <p>Translate the object along the x, y, and z axes.</p> <p> Parameters </p> <ul> <li> <p>x :  float | str \u2014 Translation distance along the x-axis.</p> </li> <li> <p>y :  float | None \u2014 Translation distance along the y-axis.</p> </li> <li> <p>z :  float | None \u2014 Translation distance along the z-axis.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 New object with the translation transformation applied.</p> </li> </ul> <p> source method Transformable.align(direction: Vector | Iterable[float]) \u2192 Self </p>"},{"location":"api/fdray/core/camera/","title":"fdray.core.camera","text":"fdray.core.camera<p> source module fdray.core.camera </p> <p>The camera implementation.</p> <p>This camera implementation is based on the following Qiita article</p> <ul> <li>Title: Efficient Camera Settings in POV-Ray</li> <li>Author: @Hyrodium (Yuto Horikawa)</li> <li>URL: https://qiita.com/Hyrodium/items/af91b1ddb8ea2c4359c2</li> <li>Date: 2017-12-07</li> </ul> <p>We adopt the spherical coordinate system for camera positioning and the calculation methods for direction, right, and up vectors as proposed in the article. The sky parameter is also included as it's essential for proper orientation.</p> <p>This camera model features:</p> <ul> <li>Intuitive camera positioning using spherical coordinates   (<code>longitude</code>, <code>latitude</code>).</li> <li>Independent control of view range (<code>view_scale</code>) and perspective   effect (<code>distance</code>).</li> <li>Rotation control via camera tilt (<code>tilt</code>).</li> <li>Proper handling of aspect ratio.</li> </ul> <p>The following code is to reproduce the image in the article.</p> <pre><code>from PIL import Image\n\nfrom fdray import Background, Camera, Color, Cylinder, LightSource, Renderer, Scene\n\nscene = Scene(\n    Background(\"white\"),\n    Camera(30, 30, view_scale=1),\n    LightSource(0, \"white\"),  # at camera location\n    Cylinder((0, 0, 0), (1, 0, 0), 0.1, Color(\"red\")),\n    Cylinder((0, 0, 0), (0, 1, 0), 0.1, Color(\"green\")),\n    Cylinder((0, 0, 0), (0, 0, 1), 0.1, Color(\"blue\")),\n)\nrenderer = Renderer(width=300, height=300)\narray = renderer.render(scene)\nImage.fromarray(array)\n</code></pre> <p> Classes </p> <ul> <li> <p>Camera \u2014 A camera for viewing 3D scenes.</p> </li> </ul> <p> source dataclass Camera(longitude: InitVar[float] = 0, latitude: InitVar[float] = 0, view_scale: float = 1, distance: float = 0, tilt: float = 0, look_at: tuple[float, float, float] = (0, 0, 0), aspect_ratio: float = 4 / 3) </p> <p>Bases : Descriptor</p> <p>A camera for viewing 3D scenes.</p> <p>Define the viewpoint and projection for a 3D scene. The camera position is specified using spherical coordinates, and various parameters allow adjusting the field of view and perspective effects.</p> <p> Attributes </p> <ul> <li> <p>longitude :  InitVar[float] \u2014 The longitude of the camera in degrees.</p> </li> <li> <p>latitude :  InitVar[float] \u2014 The latitude of the camera in degrees.</p> </li> <li> <p>view_scale :  float \u2014 The scale of the view frustum, controlling how much of the scene is visible.</p> </li> <li> <p>distance :  float \u2014 The distance of the camera from the look_at point.</p> </li> <li> <p>tilt :  float \u2014 The tilt angle of the camera in degrees (-180 to 180).</p> </li> <li> <p>look_at :  tuple[float, float, float] \u2014 The point the camera is looking at.</p> </li> <li> <p>aspect_ratio :  float \u2014 The aspect ratio of the camera.</p> </li> <li> <p>phi :  float \u2014 Internal storage for longitude in radians.</p> </li> <li> <p>theta :  float \u2014 Internal storage for latitude in radians.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>orbital_location \u2014 Calculate a position in orbit around the camera's location.</p> </li> </ul> <p> source property Camera.z: Vector </p> <p> source property Camera.x: Vector </p> <p> source property Camera.y: Vector </p> <p> source property Camera.direction: Vector </p> <p> source property Camera.location: Vector </p> <p> source property Camera.right: Vector </p> <p> source property Camera.up: Vector </p> <p> source property Camera.sky: Vector </p> <p> source method Camera.orbital_location(forward: float = 0, angle: float = 0, rotation: float = 0) \u2192 Vector </p> <p>Calculate a position in orbit around the camera's location.</p> <p>Imagine tilting your head up (angle) and then rotating counter-clockwise (rotation):</p> <ul> <li>First, move forward along viewing direction (0=at <code>camera.location</code>,   1=at <code>camera.look_at</code>). Negative values move behind the camera.</li> <li>Then, tilt up from viewing direction by 'angle' degrees</li> <li>Finally, rotate counter-clockwise from up by 'rotation' degrees   (0=up, 90=left, 180=down, 270=right)</li> </ul> <p> Parameters </p> <ul> <li> <p>forward :  float \u2014 Relative position along viewing direction (0=camera, 1=look_at, negative=behind camera)</p> </li> <li> <p>angle :  float \u2014 Tilt angle from viewing direction in degrees</p> </li> <li> <p>rotation :  float \u2014 Rotation angle from up direction in degrees (counter-clockwise)</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Vector \u2014 Position vector in absolute coordinates</p> </li> </ul>"},{"location":"api/fdray/core/color/","title":"fdray.core.color","text":"fdray.core.color<p> source module fdray.core.color </p> <p>Color definitions and utilities for ray tracing.</p> <p>This module provides classes and functions for creating and manipulating colors in POV-Ray scenes. It supports:</p> <ol> <li>Named colors (e.g., \"red\", \"blue\") and hex color codes (including #RRGGBBAA format)</li> <li>RGB and RGBA color specifications with optional filter and transmit properties</li> <li>Alpha transparency conversion to POV-Ray's transmit property</li> <li>String serialization to POV-Ray SDL format</li> </ol> <p>The module offers a rich set of predefined color names compatible with common web color standards.</p> <p> Classes </p> <ul> <li> <p>Color \u2014 A color representation with support for POV-Ray color properties.</p> </li> <li> <p>Background</p> </li> <li> <p>ColorMap</p> </li> <li> <p>ColorName \u2014 Color name enumeration with hex values.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>rgb \u2014 Return the RGB color as a tuple of floats.</p> </li> </ul> <p> source class Color(color: ColorLike, alpha: float | None = None, *, filter: float | None = None, transmit: float | None = None) </p> <p>A color representation with support for POV-Ray color properties.</p> <p>This class handles various color formats and provides conversion to POV-Ray SDL syntax. Colors can be specified by name, hex code (including #RRGGBBAA format), RGB or RGBA tuple, or by copying another Color object. Optional properties include alpha transparency, filter, and transmit values.</p> <p> Parameters </p> <ul> <li> <p>color :  ColorLike \u2014 Color specification. Can be:</p> <ul> <li>A Color object</li> <li>String name (e.g., \"red\")</li> <li>Hex code (e.g., \"#00FF00\" or \"#00FF00FF\" with alpha)</li> <li>RGB tuple (e.g., (1.0, 0.0, 0.0))</li> <li>RGBA tuple (e.g., (1.0, 0.0, 0.0, 0.5))</li> </ul> </li> <li> <p>alpha :  float | None \u2014 Alpha transparency (0.0 = fully transparent, 1.0 = fully opaque). If provided, converts to transmit value (transmit = 1 - alpha). Takes precedence over alpha in RGBA tuple or hex code.</p> </li> <li> <p>filter :  float | None \u2014 Filter property for POV-Ray (how much color filters through). Only used when specified as a keyword argument.</p> </li> <li> <p>transmit :  float | None \u2014 Transmit property for POV-Ray (how much light passes through). Only used when specified as a keyword argument.</p> </li> <li> <p>include_color \u2014 Whether to include the \"color\" keyword in string output. Defaults to True.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>red :  float \u2014 Red component (0.0 to 1.0)</p> </li> <li> <p>green :  float \u2014 Green component (0.0 to 1.0)</p> </li> <li> <p>blue :  float \u2014 Blue component (0.0 to 1.0)</p> </li> <li> <p>name :  str | None \u2014 Color name if created from a named color</p> </li> <li> <p>filter :  float | None \u2014 Filter property (how much color filters through)</p> </li> <li> <p>transmit :  float | None \u2014 Transmit property (how much light passes through)</p> </li> <li> <p>include_color :  bool \u2014 Whether to include \"color\" keyword in output</p> </li> </ul> <p> Examples </p> <pre><code>Color(\"red\")\nColor((1.0, 0.0, 0.0))\nColor((1.0, 0.0, 0.0, 0.5))  # RGBA with alpha=0.5\nColor(\"blue\", alpha=0.5)\nColor(\"#00FF00\", filter=0.3)\nColor(\"#00FF00FF\")  # Hex color with alpha\nColor(existing_color, transmit=0.7)\n</code></pre> <p> Methods </p> <ul> <li> <p>from_direction \u2014 Create a color from a direction vector.</p> </li> </ul> <p> source classmethod Color.from_direction(direction: Sequence[float], axis: int = 2) \u2192 Self </p> <p>Create a color from a direction vector.</p> <p> Parameters </p> <ul> <li> <p>direction :  Sequence[float] \u2014 The direction vector to colorize.</p> </li> <li> <p>axis :  int \u2014 The axis to colorize.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Color \u2014 The color corresponding to the direction vector.</p> </li> </ul> <p> source class Background(color: ColorLike, alpha: float | None = None, *, filter: float | None = None, transmit: float | None = None) </p> <p>Bases : Color</p> <p> source class ColorMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source rgb(color: str) \u2192 str | RGB | Color </p> <p>Return the RGB color as a tuple of floats.</p> <p>Converts a color name or hex code to an RGB tuple with values ranging from 0.0 to 1.0. If the input is a hex code with alpha (#RRGGBBAA), the alpha component is ignored for this function. If the input is not recognized as a valid color name or hex code, returns the input string unchanged.</p> <p> Parameters </p> <ul> <li> <p>color :  str \u2014 The color name (e.g., \"red\") or hex code (e.g., \"#00FF00\" or \"#00FF00FF\")</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | tuple[float, float, float] | Color \u2014 A tuple of three floats (red, green, blue) or the original string if not recognized as a valid color.</p> </li> </ul> <p> Examples </p> <pre><code>color = rgb(\"red\")\ncolor.red\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>color.green\n</code></pre> <pre><code>0.0\n</code></pre> <pre><code>color.blue\n</code></pre> <pre><code>0.0\n</code></pre> <pre><code>rgb(\"#00FF00\")\n</code></pre> <pre><code>(0.0, 1.0, 0.0)\n</code></pre> <pre><code>rgb(\"#00FF00FF\")  # Alpha component is ignored\n</code></pre> <pre><code>(0.0, 1.0, 0.0)\n</code></pre> <p> source class ColorName() </p> <p>Color name enumeration with hex values.</p>"},{"location":"api/fdray/core/light_source/","title":"fdray.core.light_source","text":"fdray.core.light_source<p> source module fdray.core.light_source </p> <p> Classes </p> <ul> <li> <p>LightSource</p> </li> <li> <p>Spotlight</p> </li> </ul> <p> source dataclass LightSource(location: Point, color: ColorLike | None = None, from_camera: bool = True, shadowless: bool = False, fade_distance: float | None = None, fade_power: float | None = None) </p> <p>Bases : Descriptor</p> <p> Methods </p> <ul> <li> <p>to_str</p> </li> </ul> <p> source property LightSource.name: str </p> <p> source method LightSource.to_str(camera: Camera | None) \u2192 str </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source dataclass Spotlight(location: Point, color: ColorLike | None = None, from_camera: bool = True, shadowless: bool = False, fade_distance: float | None = None, fade_power: float | None = None, spotlight: bool = True, radius: float | None = None, falloff: float | None = None, tightness: float | None = None, point_at: Point | None = None) </p> <p>Bases : LightSource</p>"},{"location":"api/fdray/core/media/","title":"fdray.core.media","text":"fdray.core.media<p> source module fdray.core.media </p> <p> Classes </p> <ul> <li> <p>Interior \u2014 POV-Ray interior descriptor.</p> </li> </ul> <p> source dataclass Interior(ior: float | None = None, caustics: float | None = None, dispersion: float | None = None, dispersion_samples: int | None = None, fade_distance: float | None = None, fade_power: float | None = None, fade_color: ColorLike | None = None) </p> <p>Bases : Descriptor</p> <p>POV-Ray interior descriptor.</p>"},{"location":"api/fdray/core/object/","title":"fdray.core.object","text":"fdray.core.object<p> source module fdray.core.object </p> <p>3D objects and operations for ray tracing.</p> <p>This module provides a collection of 3D object classes for ray tracing with POV-Ray. Objects can be combined using CSG operations (union, intersection, difference) and can be transformed (scale, rotate, translate). Each object can also have attributes like color, texture, or other POV-Ray specific properties.</p> <p>The module structure follows these principles:</p> <ol> <li>All objects inherit from the base class Object</li> <li>CSG operations are implemented as special object classes</li> <li>Convenience methods are provided for common transformations</li> <li>String representation of objects matches POV-Ray SDL syntax</li> </ol> <p> Classes </p> <ul> <li> <p>Object \u2014 Base class for all 3D objects.</p> </li> <li> <p>Material \u2014 Materials define the appearance of objects in the scene.</p> </li> <li> <p>Csg \u2014 Base class for Constructive Solid Geometry (CSG) operations.</p> </li> <li> <p>Union \u2014 Union of shapes - points inside any of the shapes are inside the union.</p> </li> <li> <p>Intersection \u2014 Intersection of shapes - points inside all shapes are inside the intersection.</p> </li> <li> <p>Difference \u2014 Difference of shapes - points inside the first shape and outside all others.</p> </li> <li> <p>Merge \u2014 Merge of shapes - similar to union but with different surface calculations.</p> </li> <li> <p>Box \u2014 A box defined by two corner points.</p> </li> <li> <p>Cuboid \u2014 A rectangular prism defined by a center point and dimensions.</p> </li> <li> <p>Cube \u2014 A cube defined by a center point and edge length.</p> </li> <li> <p>Cone \u2014 A cone or truncated cone between two points with specified radii.</p> </li> <li> <p>Cylinder \u2014 A cylinder defined by two points and a radius.</p> </li> <li> <p>Plane \u2014 A plane defined by a normal vector and distance from origin.</p> </li> <li> <p>SkySphere \u2014 A sky sphere that defines the background color of the scene.</p> </li> <li> <p>Sphere \u2014 A sphere defined by a center point and radius.</p> </li> <li> <p>SphereSweep \u2014 A sweep of spheres along a path with specified interpolation.</p> </li> <li> <p>Polyline \u2014 A polyline (broken line) represented as a linear sphere sweep.</p> </li> <li> <p>Curve \u2014 A smooth curve that passes through all specified points.</p> </li> <li> <p>Text \u2014 A text object defined by a string and a font.</p> </li> <li> <p>Torus \u2014 A torus defined by a center point and a radius.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>has_attributes \u2014 Check if the object has attributes.</p> </li> </ul> <p> source class Object(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p>Base class for all 3D objects.</p> <p>This class defines common behavior for all objects including:</p> <ul> <li>String serialization to POV-Ray SDL format</li> <li>CSG operations (union, intersection, difference, merge)</li> <li>Transformations (scale, rotate, translate)</li> <li>Attribute handling</li> </ul> <p> Attributes </p> <ul> <li> <p>nargs :  ClassVar[int] \u2014 Number of required arguments for this object.</p> </li> <li> <p>args :  list[Any] \u2014 List of positional arguments passed to the object.</p> </li> <li> <p>attrs :  list[Any] \u2014 List of object attributes (pigment, texture, etc.).</p> </li> </ul> <p> Methods </p> <ul> <li> <p>texture \u2014 Add a texture to the object.</p> </li> <li> <p>pigment \u2014 Add a pigment to the object.</p> </li> <li> <p>normal \u2014 Add a normal to the object.</p> </li> <li> <p>finish \u2014 Add a finish to the object.</p> </li> <li> <p>interior \u2014 Add an interior to the object.</p> </li> <li> <p>material \u2014 Add a material to the object.</p> </li> </ul> <p> source method Object.texture(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a texture to the object.</p> <p> source method Object.pigment(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a pigment to the object.</p> <p> source method Object.normal(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a normal to the object.</p> <p> source method Object.finish(ambient: float | ColorLike | None = None, emission: float | ColorLike | None = None, diffuse: float | None = None, brilliance: float | None = None, phong: float | None = None, phong_size: float | None = None, specular: float | None = None, roughness: float | None = None, metallic: float | None = None, reflection: float | ColorLike | None = None) \u2192 Self </p> <p>Add a finish to the object.</p> <p> source method Object.interior(ior: float | None = None, caustics: float | None = None, dispersion: float | None = None, dispersion_samples: int | None = None, fade_distance: float | None = None, fade_power: float | None = None, fade_color: ColorLike | None = None) \u2192 Self </p> <p>Add an interior to the object.</p> <p> source method Object.material(*args: Any, **kwargs: Any) \u2192 Self </p> <p>Add a material to the object.</p> <p> source class Material(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p>Materials define the appearance of objects in the scene.</p> <p> source has_attributes(obj: Any) \u2192 bool </p> <p>Check if the object has attributes.</p> <p> source class Csg(*args: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>Base class for Constructive Solid Geometry (CSG) operations.</p> <p> source class Union(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Union of shapes - points inside any of the shapes are inside the union.</p> <p>A union represents the boolean OR operation on shapes.</p> <p> source class Intersection(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Intersection of shapes - points inside all shapes are inside the intersection.</p> <p>An intersection represents the boolean AND operation on shapes.</p> <p> source class Difference(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Difference of shapes - points inside the first shape and outside all others.</p> <p>A difference represents the boolean subtraction operation on shapes.</p> <p> source class Merge(*args: Any, **kwargs: Any) </p> <p>Bases : Csg</p> <p>Merge of shapes - similar to union but with different surface calculations.</p> <p>A merge represents a union where internal surfaces are removed.</p> <p> source class Box(corner1: Point, corner2: Point, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A box defined by two corner points.</p> <p>A box is an axis-aligned rectangular prism defined by two opposite corners.</p> <p> Parameters </p> <ul> <li> <p>corner1 :  Point \u2014 First corner point.</p> </li> <li> <p>corner2 :  Point \u2014 Second corner point (diagonally opposite to corner1).</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cuboid(center: float | Sequence[float] | Vector, size: float | Sequence[float] | Vector, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A rectangular prism defined by a center point and dimensions.</p> <p>This is a convenience class that creates a Box centered at a specified point.</p> <p> Parameters </p> <ul> <li> <p>center :  float | Sequence[float] | Vector \u2014 Center point of the cuboid.</p> </li> <li> <p>size :  float | Sequence[float] | Vector \u2014 Dimensions (width, height, depth) of the cuboid.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cube(center: float | Sequence[float] | Vector = 0, size: float = 1, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A cube defined by a center point and edge length.</p> <p>This is a convenience class that creates a Box representing a cube.</p> <p> Parameters </p> <ul> <li> <p>center :  float | Sequence[float] | Vector \u2014 Center point of the cube.</p> </li> <li> <p>size :  float \u2014 Edge length of the cube.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cone(center1: Point, radius1: float, center2: Point, radius2: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A cone or truncated cone between two points with specified radii.</p> <p> Parameters </p> <ul> <li> <p>center1 :  Point \u2014 Center of the first end.</p> </li> <li> <p>radius1 :  float \u2014 Radius of the first end.</p> </li> <li> <p>center2 :  Point \u2014 Center of the second end.</p> </li> <li> <p>radius2 :  float \u2014 Radius of the second end.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Cylinder(center1: Point, center2: Point, radius: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A cylinder defined by two points and a radius.</p> <p> Parameters </p> <ul> <li> <p>center1 :  Point \u2014 Center of the first end.</p> </li> <li> <p>center2 :  Point \u2014 Center of the second end.</p> </li> <li> <p>radius :  float \u2014 Radius of the cylinder.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Plane(normal: Point, distance: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A plane defined by a normal vector and distance from origin.</p> <p> Parameters </p> <ul> <li> <p>normal :  Point \u2014 Normal vector of the plane.</p> </li> <li> <p>distance :  float \u2014 Distance from the origin along the normal.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class SkySphere(*args: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A sky sphere that defines the background color of the scene.</p> <p> source class Sphere(center: Point = 0, radius: float = 1, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A sphere defined by a center point and radius.</p> <p> Parameters </p> <ul> <li> <p>center :  Point \u2014 Center point of the sphere.</p> </li> <li> <p>radius :  float \u2014 Radius of the sphere.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class SphereSweep(kind: Literal['linear_spline', 'b_spline', 'cubic_spline'], centers: Sequence[Point], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A sweep of spheres along a path with specified interpolation.</p> <p>SphereSweep creates a smooth shape passing through a series of spheres using different interpolation methods.</p> <p> Parameters </p> <ul> <li> <p>kind :  Literal['linear_spline', 'b_spline', 'cubic_spline'] \u2014 Interpolation method for the sweep.</p> </li> <li> <p>centers :  Sequence[Point] \u2014 Sequence of center points for the spheres.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each sphere.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Polyline(centers: Sequence[Point] | NDArray[np.number], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A polyline (broken line) represented as a linear sphere sweep.</p> <p>This is a convenience class that creates a sphere sweep with <code>linear_spline</code> interpolation, providing a simpler interface for creating polylines.</p> <p> Parameters </p> <ul> <li> <p>centers :  Sequence[Point] | NDArray[np.number] \u2014 Sequence of 3D points or NumPy array with shape (n, 3) where n is the number of points.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each point.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_coordinates \u2014 Create a polyline from separate x, y, z coordinate sequences.</p> </li> </ul> <p> source classmethod Polyline.from_coordinates(x: Sequence[float], y: Sequence[float], z: Sequence[float], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) \u2192 Self </p> <p>Create a polyline from separate x, y, z coordinate sequences.</p> <p> Parameters </p> <ul> <li> <p>x :  Sequence[float] \u2014 Sequence of x-coordinates.</p> </li> <li> <p>y :  Sequence[float] \u2014 Sequence of y-coordinates.</p> </li> <li> <p>z :  Sequence[float] \u2014 Sequence of z-coordinates.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each point.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 New Polyline instance.</p> </li> </ul> <p> source class Curve(centers: Sequence[Point] | NDArray[np.number], radius: float | Sequence[float], *attrs: Any, **kwargs: Any) </p> <p>Bases : Polyline</p> <p>A smooth curve that passes through all specified points.</p> <p>Create a cubic spline sphere sweep that is guaranteed to pass through all given points, including the start and end points. It uses ghost points to ensure proper curve behavior at the endpoints.</p> <p>Unlike standard cubic splines which may not pass through the endpoints, this implementation ensures the curve follows all specified points exactly.</p> <p> Parameters </p> <ul> <li> <p>centers :  Sequence[Point] | NDArray[np.number] \u2014 Sequence of 3D points or NumPy array with shape (n, 3) where n is the number of points.</p> </li> <li> <p>radius :  float | Sequence[float] \u2014 Constant radius or sequence of radii for each point.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> source class Text(text: str, thickness: float = 0, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A text object defined by a string and a font.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The text string to display.</p> </li> <li> <p>font \u2014 The font to use for the text.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>align \u2014 Align the text with the given longitude and latitude.</p> </li> <li> <p>set_font \u2014 Set the font file for the text object.</p> </li> </ul> <p> source method Text.align(longitude: float = 0, latitude: float = 0) \u2192 Self </p> <p>Align the text with the given longitude and latitude.</p> <p> Parameters </p> <ul> <li> <p>longitude :  float \u2014 The longitude of the text.</p> </li> <li> <p>latitude :  float \u2014 The latitude of the text.</p> </li> </ul> <p> source classmethod Text.set_font(font_spec: str | Path) \u2192 str | None </p> <p>Set the font file for the text object.</p> <p>This method determines how to handle the font specification based on its format:</p> <ul> <li>If <code>font_spec</code> ends with '.ttf', it's treated as a direct file path.</li> <li>Otherwise, it's treated as a font name to search in system fonts.</li> </ul> <p> Parameters </p> <ul> <li> <p>font_spec :  str | Path \u2014 Font specification, either a path to a TTF file or a font name. If it's a font name, the method will search for matching fonts in the system fonts directory.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 Path to the font file if found, None otherwise.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ImportError \u2014 If matplotlib is not installed and a font name search is attempted.</p> </li> </ul> <p> source class Torus(major_radius: float, minor_radius: float, *attrs: Any, **kwargs: Any) </p> <p>Bases : Object</p> <p>A torus defined by a center point and a radius.</p> <p> Parameters </p> <ul> <li> <p>major_radius :  float \u2014 Major radius of the torus.</p> </li> <li> <p>minor_radius :  float \u2014 Minor radius of the torus.</p> </li> <li> <p>*attrs :  Any \u2014 Additional attributes.</p> </li> <li> <p>**kwargs :  Any \u2014 Additional keyword attributes.</p> </li> </ul>"},{"location":"api/fdray/core/renderer/","title":"fdray.core.renderer","text":"fdray.core.renderer<p> source module fdray.core.renderer </p> <p> Classes </p> <ul> <li> <p>RenderError \u2014 Rendering error</p> </li> <li> <p>Renderer</p> </li> </ul> <p> Functions </p> <ul> <li> <p>to_switch \u2014 Convert a boolean value to a string 'on' or 'off'.</p> </li> <li> <p>antialias_option \u2014 Convert a boolean value to a string 'on' or 'off'.</p> </li> <li> <p>create_input_file \u2014 Create a temporary file containing the POV-Ray scene.</p> </li> <li> <p>remove_progress</p> </li> </ul> <p> source class RenderError(stderr: str) </p> <p>Bases : Exception</p> <p>Rendering error</p> <p> source class Renderer(width: int | None = None, height: int | None = None, output_alpha: bool | None = None, quality: int | None = None, antialias: bool | float | None = None, threads: int | None = None, display: bool | None = None) </p> <p> Methods </p> <ul> <li> <p>build \u2014 Build the command line arguments for the POV-Ray renderer.</p> </li> <li> <p>render \u2014 Render a POV-Ray scene.</p> </li> </ul> <p> source method Renderer.build(scene: str, output_file: str | Path | None = None) \u2192 list[str] </p> <p>Build the command line arguments for the POV-Ray renderer.</p> <p> Parameters </p> <ul> <li> <p>scene :  str \u2014 The scene description.</p> </li> <li> <p>output_file :  str | Path | None \u2014 The output file path.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[str] \u2014 The command line arguments.</p> </li> </ul> <p> source method Renderer.render(scene: Any, output_file: str | Path | None = None, *, return_image: bool = False, trim: bool | int = False) \u2192 NDArray[np.uint8] | Image.Image | None </p> <p>Render a POV-Ray scene.</p> <p> Parameters </p> <ul> <li> <p>scene :  Any \u2014 POV-Ray scene description output_file: Output image file path.     If None, returns a numpy array instead of saving to file. return_image: If True, returns a PIL image instead of a numpy array. trim: If True, trim the output image to the non-transparent region.</p> </li> <li> <p>Returns \u2014 NDArray[np.uint8] | Image.Image | None: RGB(A) image array or PIL image if output_file is None</p> </li> </ul> <p> Raises </p> <ul> <li> <p>RenderError</p> </li> </ul> <p> source to_switch(value: bool) \u2192 str </p> <p>Convert a boolean value to a string 'on' or 'off'.</p> <p> source antialias_option(antialias: bool | float) \u2192 str </p> <p>Convert a boolean value to a string 'on' or 'off'.</p> <p> source create_input_file(scene: str) \u2192 Path </p> <p>Create a temporary file containing the POV-Ray scene.</p> <p> Parameters </p> <ul> <li> <p>scene :  str \u2014 POV-Ray scene description</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Path \u2014 Path to the created scene file</p> </li> </ul> <p>Note</p> <p>The temporary directory and its contents will be automatically deleted when the program exits.</p> <p> source remove_progress(stderr: str) \u2192 str </p>"},{"location":"api/fdray/core/scene/","title":"fdray.core.scene","text":"fdray.core.scene<p> source module fdray.core.scene </p> <p> Classes </p> <ul> <li> <p>GlobalSettings</p> </li> <li> <p>Include</p> </li> <li> <p>Scene \u2014 A scene is a collection of elements.</p> </li> </ul> <p> source dataclass GlobalSettings(ambient_light: ColorLike | None = None, assumed_gamma: float = 1) </p> <p>Bases : Descriptor</p> <p> source class Include(*filenames: str) </p> <p> source class Scene(*attrs: Any) </p> <p>A scene is a collection of elements.</p> <p> Methods </p> <ul> <li> <p>set</p> </li> <li> <p>copy</p> </li> <li> <p>add</p> </li> <li> <p>to_str \u2014 Create a string representation of the scene with the given image dimensions.</p> </li> <li> <p>render \u2014 Render the scene with the given image dimensions.</p> </li> </ul> <p> source method Scene.set(*attrs: Any) \u2192 Self </p> <p> source method Scene.copy() \u2192 Self </p> <p> source method Scene.add(*attrs: Any) \u2192 Self </p> <p> source method Scene.to_str(width: int, height: int) \u2192 str </p> <p>Create a string representation of the scene with the given image dimensions.</p> <p> Parameters </p> <ul> <li> <p>width :  int \u2014 The width of the image.</p> </li> <li> <p>height :  int \u2014 The height of the image.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A string representation of the scene.</p> </li> </ul> <p> source method Scene.render(width: int | None = None, height: int | None = None, output_alpha: bool | None = None, quality: int | None = None, antialias: bool | float | None = None, threads: int | None = None, *, trim: bool | int = False) \u2192 Image.Image </p> <p>Render the scene with the given image dimensions.</p> <p> Parameters </p> <ul> <li> <p>width :  int | None \u2014 The width of the image.</p> </li> <li> <p>height :  int | None \u2014 The height of the image.</p> </li> <li> <p>output_alpha :  bool | None \u2014 If True, output an image with an alpha channel.</p> </li> <li> <p>quality :  int | None \u2014 The quality of the image.</p> </li> <li> <p>antialias :  bool | float | None \u2014 The antialiasing level.</p> </li> <li> <p>threads :  int | None \u2014 The number of threads to use.</p> </li> <li> <p>trim :  bool | int \u2014 If True, trim the output image to the non-transparent region. If an integer, trim the output image to the non-transparent region by the given margin.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Image.Image \u2014 The rendered image.</p> </li> </ul>"},{"location":"api/fdray/core/texture/","title":"fdray.core.texture","text":"fdray.core.texture<p> source module fdray.core.texture </p> <p> Classes </p> <ul> <li> <p>Texture</p> </li> <li> <p>InteriorTexture</p> </li> <li> <p>TextureMap</p> </li> <li> <p>Pigment</p> </li> <li> <p>PigmentMap</p> </li> <li> <p>Normal</p> </li> <li> <p>NormalMap</p> </li> <li> <p>SlopeMap</p> </li> <li> <p>Finish \u2014 POV-Ray finish attributes.</p> </li> </ul> <p> source class Texture(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> source class InteriorTexture(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> source class TextureMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source class Pigment(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> Methods </p> <ul> <li> <p>uv_mapping \u2014 Create a UV mapping pigment from image data.</p> </li> </ul> <p> source classmethod Pigment.uv_mapping(data: str | Path | NDArray[Any] | Image, interpolate: int = 2) \u2192 Self </p> <p>Create a UV mapping pigment from image data.</p> <p> Parameters </p> <ul> <li> <p>data :  str | Path | NDArray | Image \u2014 The image data. Can be a file path, NumPy array, or PIL Image.</p> </li> <li> <p>interpolate :  int, optional \u2014 The interpolation method. Defaults to 2. 0: none, 1: linear, 2: bilinear, 3: trilinear, 4: bicubic.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 A Pigment instance with UV mapping.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError \u2014 If the image file does not exist.</p> </li> <li> <p>ValueError \u2014 If the interpolation value is invalid.</p> </li> </ul> <p> source class PigmentMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source class Normal(*args: Any, **kwargs: Any) </p> <p>Bases : Transformable</p> <p> source class NormalMap(*args: Iterable[Any]) </p> <p>Bases : Map</p> <p> source class SlopeMap(*args: tuple[float, Sequence[float]]) </p> <p>Bases : Map</p> <p> source dataclass Finish(ambient: float | ColorLike | None = None, emission: float | ColorLike | None = None, diffuse: float | None = None, brilliance: float | None = None, phong: float | None = None, phong_size: float | None = None, specular: float | None = None, roughness: float | None = None, metallic: float | None = None, reflection: float | ColorLike | None = None) </p> <p>Bases : Descriptor</p> <p>POV-Ray finish attributes.</p>"},{"location":"api/fdray/data/","title":"fdray.data","text":"fdray.data<p> source package fdray.data </p> <p> Functions </p> <ul> <li> <p>from_spherical_coordinates \u2014 Generate Cartesian coordinates from spherical coordinates.</p> </li> <li> <p>to_spherical_coordinates \u2014 Convert Cartesian coordinates to spherical coordinates.</p> </li> <li> <p>visualize_spherical_data \u2014 Visualize spherical coordinate data as an image.</p> </li> </ul> <p> source from_spherical_coordinates(x: str = 'x', y: str = 'y', z: str = 'z', step_phi: int = 3, step_theta: int = 2) \u2192 DataFrame </p> <p>Generate Cartesian coordinates from spherical coordinates.</p> <p>This function generates a grid of points on a unit sphere by converting spherical coordinates to Cartesian coordinates. The coordinates are generated with the following ranges:</p> <pre><code>- phi: [0, 360) degrees with step_phi\n- theta: [0, 180] degrees with step_theta\n</code></pre> <p> The coordinates correspond to POV-Ray's uv_mapping as follows </p> <pre><code>- North pole (theta = 0\u00b0) is at y = 1\n- South pole (theta = 180\u00b0) is at y = -1\n- phi = 0\u00b0 is along the positive x-axis\n- The image's top edge (v = 0) maps to y = 1\n- The image's bottom edge (v = 1) maps to y = -1\n- The image's left and right edges connect at x-axis\n</code></pre> <p> Parameters </p> <ul> <li> <p>x :  str, optional \u2014 Column name for x-coordinate. Defaults to \"x\".</p> </li> <li> <p>y :  str, optional \u2014 Column name for y-coordinate. Defaults to \"y\".</p> </li> <li> <p>z :  str, optional \u2014 Column name for z-coordinate. Defaults to \"z\".</p> </li> <li> <p>step_phi :  int, optional \u2014 Step size for azimuthal angle in degrees. Must be a divisor of 360. Defaults to 3.</p> </li> <li> <p>step_theta :  int, optional \u2014 Step size for polar angle in degrees. Must be a divisor of 180. Defaults to 2.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>DataFrame \u2014 DataFrame containing Cartesian coordinates (x, y, z) of points     on a unit sphere.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If step_phi is not a divisor of 360 or step_theta is not a divisor of 180.</p> </li> </ul> <p> source to_spherical_coordinates(df: DataFrame, x: str = 'x', y: str = 'y', z: str = 'z') \u2192 DataFrame </p> <p>Convert Cartesian coordinates to spherical coordinates.</p> <p>This function converts Cartesian coordinates (x, y, z) to spherical coordinates (theta, phi) and handles special cases:</p> <ul> <li>Normalizes phi to [0, 360] degrees</li> <li>Duplicates data at poles (theta = 0, 180) for all phi values</li> <li>Adds data at phi = 360 for continuity</li> </ul> <p> The coordinate transformation follows these equations </p> <pre><code># Cartesian to spherical\ntheta = arccos(y)  # polar angle [0, 180] degrees\nphi = arctan2(z, x)  # azimuthal angle [0, 360] degrees\n\n# Spherical to Cartesian\nx = sin(theta) * cos(phi)\ny = cos(theta)\nz = sin(theta) * sin(phi)\n</code></pre> <p> The coordinates correspond to POV-Ray's uv_mapping as follows </p> <pre><code>- North pole (theta = 0\u00b0) is at y = 1\n- South pole (theta = 180\u00b0) is at y = -1\n- phi = 0\u00b0 is along the positive x-axis\n- The image's top edge (v = 0) maps to y = 1\n- The image's bottom edge (v = 1) maps to y = -1\n- The image's left and right edges connect at x-axis\n</code></pre> <p> Parameters </p> <ul> <li> <p>df :  DataFrame \u2014 Input DataFrame containing Cartesian coordinates.</p> </li> <li> <p>x :  str, optional \u2014 Column name for x-coordinate. Defaults to \"x\".</p> </li> <li> <p>y :  str, optional \u2014 Column name for y-coordinate. Defaults to \"y\".</p> </li> <li> <p>z :  str, optional \u2014 Column name for z-coordinate. Defaults to \"z\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>DataFrame \u2014 DataFrame with added theta and phi columns.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If required columns are missing.</p> </li> </ul> <p> source visualize_spherical_data(df: DataFrame, value: str, phi: str = 'phi', theta: str = 'theta', scale: float = 1, vmin: float | None = None, vmax: float | None = None, cmap_name: str = 'jet') \u2192 Image.Image </p> <p>Visualize spherical coordinate data as an image.</p> <p> Parameters </p> <ul> <li> <p>df :  DataFrame \u2014 Input DataFrame containing spherical coordinate data.</p> </li> <li> <p>value :  str \u2014 Column name for the values to be visualized.</p> </li> <li> <p>phi :  str, optional \u2014 Column name for azimuthal angle. Defaults to \"phi\".</p> </li> <li> <p>theta :  str, optional \u2014 Column name for polar angle. Defaults to \"theta\".</p> </li> <li> <p>scale :  float, optional \u2014 Scale factor for the output image. Defaults to 1.</p> </li> <li> <p>vmin :  float | None, optional \u2014 Minimum value for normalization. Defaults to None.</p> </li> <li> <p>vmax :  float | None, optional \u2014 Maximum value for normalization. Defaults to None.</p> </li> <li> <p>cmap_name :  str, optional \u2014 Name of the colormap to use. Defaults to \"jet\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Image.Image \u2014 The generated spherical image.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If required columns are missing or if scale is invalid.</p> </li> <li> <p>KeyError \u2014 If the specified colormap does not exist.</p> </li> </ul>"},{"location":"api/fdray/data/color/","title":"fdray.data.color","text":"fdray.data.color<p> source module fdray.data.color </p> <p> Functions </p> <ul> <li> <p>raise_import_error</p> </li> <li> <p>get_colormap \u2014 Get a list of colors from a named colormap.</p> </li> <li> <p>colorize_direction_field \u2014 Colorize a vector field as colors based on vector directions.</p> </li> <li> <p>colorize_direction \u2014 Colorize a single direction vector.</p> </li> </ul> <p> source raise_import_error(msg: str) \u2192 Never </p> <p> Raises </p> <ul> <li> <p>ImportError</p> </li> </ul> <p> source get_colormap(name: str, num_colors: int = 256) \u2192 list[RGB] </p> <p>Get a list of colors from a named colormap.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 Name of the colormap (e.g., 'viridis', 'plasma', etc.)</p> </li> <li> <p>num_colors :  int \u2014 Number of colors to include in the colormap</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[tuple[float, float, float]] \u2014 List of RGB tuples representing the colormap</p> </li> </ul> <p> source colorize_direction_field(field: Sequence[Any] | NDArray[np.number], axis: int = 2) \u2192 NDArray[np.float64] </p> <p>Colorize a vector field as colors based on vector directions.</p> <p>This function maps direction vectors to colors using a spherical color mapping:</p> <ul> <li>Azimuthal angle (XY plane) determines the hue</li> <li>Polar angle (Z component) affects saturation and value</li> </ul> <p>Note</p> <p>Input vectors must be normalized (unit length). No normalization is performed by this function. Use <code>colorize_direction</code> for automatic normalization of single vectors.</p> <p> Parameters </p> <ul> <li> <p>field :  Sequence | NDArray \u2014 Array of direction vectors to colorize. Last dimension should contain vector components.</p> </li> <li> <p>axis :  int \u2014 Principal axis index (0=X, 1=Y, 2=Z). Default is 2 (Z-axis).</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NDArray[np.float64] \u2014 Array of RGB colors corresponding to the input vector directions.</p> </li> </ul> <p> Requires </p> <p>matplotlib for HSV to RGB conversion.</p> <p> source colorize_direction(vector: Sequence[float], axis: int = 2) \u2192 RGB </p> <p>Colorize a single direction vector.</p> <p>This function converts a direction vector to a color based on its orientation. The vector is automatically normalized to unit length before encoding.</p> <p> Parameters </p> <ul> <li> <p>vector :  Sequence | NDArray \u2014 Direction vector to colorize.</p> </li> <li> <p>axis :  int \u2014 Principal axis index (0=X, 1=Y, 2=Z). Default is 2 (Z-axis).</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[float, float, float] \u2014 A tuple of RGB floats representing the colorized direction.</p> </li> </ul> <p> Requires </p> <p>matplotlib for HSV to RGB conversion.</p>"},{"location":"api/fdray/data/field/","title":"fdray.data.field","text":"fdray.data.field<p> source module fdray.data.field </p> <p> Classes </p> <ul> <li> <p>Union</p> </li> </ul> <p> Functions </p> <ul> <li> <p>iter_objects_from_callable</p> </li> <li> <p>iter_objects_from_dict</p> </li> <li> <p>get_indices</p> </li> <li> <p>get_default_mapping</p> </li> <li> <p>translate</p> </li> </ul> <p> source class Union(*args: Any, **kwargs: Any) </p> <p>Bases : BaseUnion</p> <p> Methods </p> <ul> <li> <p>from_field \u2014 Create objects from scalar, vector or tensor fields.</p> </li> <li> <p>from_region \u2014 Create objects from a discrete region.</p> </li> </ul> <p> source classmethod Union.from_field(field: Sequence[Any] | NDArray[Any], obj: Callable[[Any], Object | Iterable[Object] | None], spacing: float | tuple[float, ...] = 1, ndim: int = 1, mask: Sequence[Any] | NDArray[Any] | None = None, *, as_union: bool = True) \u2192 Self | list[Object] </p> <p>Create objects from scalar, vector or tensor fields.</p> <p>This function generates 3D objects from field data. The last <code>ndim</code> dimensions of the input array are considered as field components.</p> <p> Parameters </p> <ul> <li> <p>field :  Sequence | NDArray \u2014 Array containing field data</p> </li> <li> <p>obj :  Callable[[Any], Object | Iterable[Object] | None] \u2014 Function that takes field data at a position and returns an Object (or None to skip)</p> </li> <li> <p>spacing :  float | tuple[float, ...] \u2014 Distance between objects (scalar or per-dimension)</p> </li> <li> <p>ndim :  int \u2014 Number of dimensions to treat as field components:</p> <ul> <li>ndim=0: Scalar field (all dimensions used for positioning)</li> <li>ndim=1: Vector field (last dimension contains vector components)</li> <li>ndim=2: Tensor field (last two dimensions contain tensor components)</li> </ul> </li> <li> <p>mask :  Sequence | NDArray | None \u2014 Boolean mask to filter field data</p> </li> <li> <p>as_union :  bool \u2014 Whether to return a Union object or a list of objects</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self | list[Object] \u2014 Union object or list of objects representing the field</p> </li> </ul> <p> source classmethod Union.from_region(region: Sequence[Any] | NDArray[Any], obj: Object | Callable[[Any], Object | Iterable[Object] | None] | None = None, spacing: float | tuple[float, ...] = 1, mapping: Mapping[Any, Any] | None = None, *, as_union: bool = True) \u2192 Self | list[Object] </p> <p>Create objects from a discrete region.</p> <p>This function generates 3D objects from a discrete region, where each unique value in the region corresponds to an object with specific attributes.</p> <p>The function supports two modes:</p> <ol> <li>Base object + attribute mapping: Provide an Object instance and a mapping of region values to attributes (e.g., colors).</li> <li>Custom object generation: Provide a callback function that takes a region value and returns an Object (similar to from_field).</li> </ol> <p> Parameters </p> <ul> <li> <p>region :  Sequence | NDArray \u2014 Array containing region data (discrete values)</p> </li> <li> <p>obj :  Object | Callable[[Any], Object | Iterable[Object] | None] | None \u2014 Either an Object instance to be used as base, or a function that takes a region value and returns an Object, or None to use a default Cube</p> </li> <li> <p>spacing :  float | tuple[float, ...] \u2014 Distance between objects (scalar or per-dimension)</p> </li> <li> <p>mapping :  Mapping[Any, Any] | None \u2014 Mapping from region values to attributes (used only when obj is an Object)</p> </li> <li> <p>as_union :  bool \u2014 Whether to return a Union object or a list of objects</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self | list[Object] \u2014 Union object or list of objects representing the region</p> </li> </ul> <p> source iter_objects_from_callable(obj: Callable[[Any], Object | Iterable[Object] | None], field: Sequence[Any] | NDArray[Any], spacing: float | tuple[float, ...] = 1, ndim: int = 1, mask: Sequence[Any] | NDArray[Any] | None = None) \u2192 Iterator[Object] </p> <p> source iter_objects_from_dict(objects: dict[Any, Object], region: Sequence[Any] | NDArray[Any], spacing: float | tuple[float, ...] = 1) \u2192 Iterator[Object] </p> <p> source get_indices(region: Sequence[Any] | NDArray[Any]) \u2192 dict[Any, list[tuple[int, ...]]] </p> <p> source get_default_mapping(region: Sequence[Any] | NDArray[Any]) \u2192 dict[Any, Any] </p> <p> source translate(obj: Object, indices: Iterable[Iterable[float]], spacing: float | Iterable[float] = 1, offset: float | Iterable[float] = 0) \u2192 Iterator[Object] </p>"},{"location":"api/fdray/data/frame/","title":"fdray.data.frame","text":"fdray.data.frame<p> source module fdray.data.frame </p> <p> Functions </p> <ul> <li> <p>from_spherical_coordinates \u2014 Generate Cartesian coordinates from spherical coordinates.</p> </li> <li> <p>to_spherical_coordinates \u2014 Convert Cartesian coordinates to spherical coordinates.</p> </li> <li> <p>visualize_spherical_data \u2014 Visualize spherical coordinate data as an image.</p> </li> </ul> <p> source from_spherical_coordinates(x: str = 'x', y: str = 'y', z: str = 'z', step_phi: int = 3, step_theta: int = 2) \u2192 DataFrame </p> <p>Generate Cartesian coordinates from spherical coordinates.</p> <p>This function generates a grid of points on a unit sphere by converting spherical coordinates to Cartesian coordinates. The coordinates are generated with the following ranges:</p> <pre><code>- phi: [0, 360) degrees with step_phi\n- theta: [0, 180] degrees with step_theta\n</code></pre> <p> The coordinates correspond to POV-Ray's uv_mapping as follows </p> <pre><code>- North pole (theta = 0\u00b0) is at y = 1\n- South pole (theta = 180\u00b0) is at y = -1\n- phi = 0\u00b0 is along the positive x-axis\n- The image's top edge (v = 0) maps to y = 1\n- The image's bottom edge (v = 1) maps to y = -1\n- The image's left and right edges connect at x-axis\n</code></pre> <p> Parameters </p> <ul> <li> <p>x :  str, optional \u2014 Column name for x-coordinate. Defaults to \"x\".</p> </li> <li> <p>y :  str, optional \u2014 Column name for y-coordinate. Defaults to \"y\".</p> </li> <li> <p>z :  str, optional \u2014 Column name for z-coordinate. Defaults to \"z\".</p> </li> <li> <p>step_phi :  int, optional \u2014 Step size for azimuthal angle in degrees. Must be a divisor of 360. Defaults to 3.</p> </li> <li> <p>step_theta :  int, optional \u2014 Step size for polar angle in degrees. Must be a divisor of 180. Defaults to 2.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>DataFrame \u2014 DataFrame containing Cartesian coordinates (x, y, z) of points     on a unit sphere.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If step_phi is not a divisor of 360 or step_theta is not a divisor of 180.</p> </li> </ul> <p> source to_spherical_coordinates(df: DataFrame, x: str = 'x', y: str = 'y', z: str = 'z') \u2192 DataFrame </p> <p>Convert Cartesian coordinates to spherical coordinates.</p> <p>This function converts Cartesian coordinates (x, y, z) to spherical coordinates (theta, phi) and handles special cases:</p> <ul> <li>Normalizes phi to [0, 360] degrees</li> <li>Duplicates data at poles (theta = 0, 180) for all phi values</li> <li>Adds data at phi = 360 for continuity</li> </ul> <p> The coordinate transformation follows these equations </p> <pre><code># Cartesian to spherical\ntheta = arccos(y)  # polar angle [0, 180] degrees\nphi = arctan2(z, x)  # azimuthal angle [0, 360] degrees\n\n# Spherical to Cartesian\nx = sin(theta) * cos(phi)\ny = cos(theta)\nz = sin(theta) * sin(phi)\n</code></pre> <p> The coordinates correspond to POV-Ray's uv_mapping as follows </p> <pre><code>- North pole (theta = 0\u00b0) is at y = 1\n- South pole (theta = 180\u00b0) is at y = -1\n- phi = 0\u00b0 is along the positive x-axis\n- The image's top edge (v = 0) maps to y = 1\n- The image's bottom edge (v = 1) maps to y = -1\n- The image's left and right edges connect at x-axis\n</code></pre> <p> Parameters </p> <ul> <li> <p>df :  DataFrame \u2014 Input DataFrame containing Cartesian coordinates.</p> </li> <li> <p>x :  str, optional \u2014 Column name for x-coordinate. Defaults to \"x\".</p> </li> <li> <p>y :  str, optional \u2014 Column name for y-coordinate. Defaults to \"y\".</p> </li> <li> <p>z :  str, optional \u2014 Column name for z-coordinate. Defaults to \"z\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>DataFrame \u2014 DataFrame with added theta and phi columns.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If required columns are missing.</p> </li> </ul> <p> source visualize_spherical_data(df: DataFrame, value: str, phi: str = 'phi', theta: str = 'theta', scale: float = 1, vmin: float | None = None, vmax: float | None = None, cmap_name: str = 'jet') \u2192 Image.Image </p> <p>Visualize spherical coordinate data as an image.</p> <p> Parameters </p> <ul> <li> <p>df :  DataFrame \u2014 Input DataFrame containing spherical coordinate data.</p> </li> <li> <p>value :  str \u2014 Column name for the values to be visualized.</p> </li> <li> <p>phi :  str, optional \u2014 Column name for azimuthal angle. Defaults to \"phi\".</p> </li> <li> <p>theta :  str, optional \u2014 Column name for polar angle. Defaults to \"theta\".</p> </li> <li> <p>scale :  float, optional \u2014 Scale factor for the output image. Defaults to 1.</p> </li> <li> <p>vmin :  float | None, optional \u2014 Minimum value for normalization. Defaults to None.</p> </li> <li> <p>vmax :  float | None, optional \u2014 Maximum value for normalization. Defaults to None.</p> </li> <li> <p>cmap_name :  str, optional \u2014 Name of the colormap to use. Defaults to \"jet\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Image.Image \u2014 The generated spherical image.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If required columns are missing or if scale is invalid.</p> </li> <li> <p>KeyError \u2014 If the specified colormap does not exist.</p> </li> </ul>"},{"location":"api/fdray/utils/","title":"fdray.utils","text":"fdray.utils<p> source package fdray.utils </p> <p> Modules </p> <ul> <li> <p>fdray.utils.format</p> </li> <li> <p>fdray.utils.image</p> </li> <li> <p>fdray.utils.string</p> </li> <li> <p>fdray.utils.vector</p> </li> </ul>"},{"location":"api/fdray/utils/format/","title":"fdray.utils.format","text":"fdray.utils.format<p> source module fdray.utils.format </p> <p> Functions </p> <ul> <li> <p>format_code</p> </li> <li> <p>iter_codes</p> </li> <li> <p>iter_lines</p> </li> <li> <p>split_line</p> </li> <li> <p>iter_maps</p> </li> <li> <p>to_html</p> </li> </ul> <p> source format_code(text: str) \u2192 str </p> <p> source iter_codes(text: str) \u2192 Iterator[str] </p> <p> source iter_lines(line: str, indent: int = 0) \u2192 Iterator[str] </p> <p> source split_line(line: str) \u2192 tuple[str, str, str] </p> <p> source iter_maps(line: str) \u2192 Iterator[str] </p> <p> source to_html(code: str) \u2192 str </p>"},{"location":"api/fdray/utils/image/","title":"fdray.utils.image","text":"fdray.utils.image<p> source module fdray.utils.image </p> <p> Functions </p> <ul> <li> <p>trim \u2014 Trim the output image to the non-transparent region.</p> </li> <li> <p>save \u2014 Save the image data to a temporary file.</p> </li> </ul> <p> source trim(image: Image.Image, margin: int = 0) \u2192 Image.Image </p> <p>Trim the output image to the non-transparent region.</p> <p> Parameters </p> <ul> <li> <p>image :  Image.Image \u2014 The output image.</p> </li> <li> <p>margin :  int \u2014 The margin to trim.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Image.Image \u2014 The trimmed image.</p> </li> </ul> <p> source save(data: NDArray | Image.Image) \u2192 Path </p> <p>Save the image data to a temporary file.</p> <p>The file will be deleted when the program exits.</p> <p> Parameters </p> <ul> <li> <p>data :  NDArray | Image.Image \u2014 The image data to save.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Path \u2014 The path to the saved file.</p> </li> </ul>"},{"location":"api/fdray/utils/string/","title":"fdray.utils.string","text":"fdray.utils.string<p> source module fdray.utils.string </p> <p> Functions </p> <ul> <li> <p>to_snake_case</p> </li> <li> <p>to_str</p> </li> <li> <p>convert</p> </li> </ul> <p> source to_snake_case(name: str) \u2192 str </p> <p> source to_str(arg: Any) \u2192 str </p> <p> source convert(arg: Any) \u2192 str </p>"},{"location":"api/fdray/utils/vector/","title":"fdray.utils.vector","text":"fdray.utils.vector<p> source module fdray.utils.vector </p> <p> Classes </p> <ul> <li> <p>Vector</p> </li> </ul> <p> source class Vector(x: float | Iterable[float], y: float | None = None, z: float | None = None) </p> <p> Methods </p> <ul> <li> <p>norm</p> </li> <li> <p>normalize \u2014 Normalize the vector to unit length.</p> </li> <li> <p>dot \u2014 Compute the dot product of two vectors.</p> </li> <li> <p>cross \u2014 Compute the cross product of two vectors.</p> </li> <li> <p>rotate \u2014 Rotate a vector around an axis by an angle (Rodrigues' rotation formula).</p> </li> <li> <p>reflect \u2014 Reflect this vector across another vector.</p> </li> <li> <p>angle \u2014 Calculate angle between two vectors in radians.</p> </li> <li> <p>from_spherical \u2014 Create a vector from spherical coordinates.</p> </li> <li> <p>to_spherical \u2014 Convert vector to spherical coordinates.</p> </li> </ul> <p> source method Vector.norm() \u2192 float </p> <p> source method Vector.normalize() \u2192 Self </p> <p>Normalize the vector to unit length.</p> <p> Returns </p> <ul> <li> <p>Self \u2014 The normalized vector.</p> </li> </ul> <p> source method Vector.dot(other: Vector | Iterable[float]) \u2192 float </p> <p>Compute the dot product of two vectors.</p> <p> Parameters </p> <ul> <li> <p>other :  Vector | Iterable[float] \u2014 The vector to dot with</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 The dot product of the two vectors.</p> </li> </ul> <p> source method Vector.cross(other: Vector | Iterable[float]) \u2192 Self </p> <p>Compute the cross product of two vectors.</p> <p> Parameters </p> <ul> <li> <p>other :  Vector | Iterable[float] \u2014 The vector to cross with</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 The cross product of the two vectors.</p> </li> </ul> <p> source method Vector.rotate(axis: Vector | Iterable[float], theta: float) \u2192 Self </p> <p>Rotate a vector around an axis by an angle (Rodrigues' rotation formula).</p> <p> Parameters </p> <ul> <li> <p>axis :  Vector | Iterable[float] \u2014 The axis of rotation (will be normalized).</p> </li> <li> <p>theta :  float \u2014 The angle of rotation in radians.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Vector \u2014 The rotated vector.</p> </li> </ul> <p> source method Vector.reflect(across: Vector | Iterable[float]) \u2192 Self </p> <p>Reflect this vector across another vector.</p> <p> Parameters </p> <ul> <li> <p>across :  Vector | Iterable[float] \u2014 The vector to reflect across</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 The reflected vector</p> </li> </ul> <p> source method Vector.angle(other: Vector | Iterable[float]) \u2192 float </p> <p>Calculate angle between two vectors in radians.</p> <p> Parameters </p> <ul> <li> <p>other :  Vector | Iterable[float] \u2014 Another vector to calculate angle with</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 Angle between vectors in radians (0-\u03c0)</p> </li> </ul> <p> source classmethod Vector.from_spherical(phi: float, theta: float) \u2192 Self </p> <p>Create a vector from spherical coordinates.</p> <p> Parameters </p> <ul> <li> <p>phi :  float \u2014 azimuthal angle in radians (-\u03c0 to \u03c0 or 0 to 2\u03c0) 0 on x-axis, \u03c0/2 on y-axis</p> </li> <li> <p>theta :  float \u2014 polar angle in radians (-\u03c0/2 to \u03c0/2) 0 at equator, \u03c0/2 at north pole, -\u03c0/2 at south pole</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Vector \u2014 unit vector (x, y, z) where:     x = cos(\u03b8)cos(\u03c6)     y = cos(\u03b8)sin(\u03c6)     z = sin(\u03b8)</p> </li> </ul> <p> source method Vector.to_spherical() \u2192 tuple[float, float] </p> <p>Convert vector to spherical coordinates.</p> <p> Returns </p> <ul> <li> <p>tuple[float, float] \u2014 A tuple of (phi, theta) where</p> <ul> <li>phi: azimuthal angle in radians (-\u03c0 to \u03c0),   0 on x-axis, \u03c0/2 on y-axis</li> <li>theta: polar angle in radians (-\u03c0/2 to \u03c0/2),   0 at equator, \u03c0/2 at north pole, -\u03c0/2 at south pole</li> </ul> </li> </ul>"},{"location":"api/fdray/typing/","title":"fdray.typing","text":"fdray.typing<p> source module fdray.typing </p>"}]}